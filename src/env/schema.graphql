schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

# History of auditable actions on audited tables, from audit.if_modified_func()
#
#
# columns and relationships of "audit.logged_actions"
#
type audit_logged_actions implements Node {
  # Action type; I = insert, D = delete, U = update, T = truncate
  action: String!

  # Wall clock time at which audited event's trigger call occurred
  action_tstamp_clk: timestamptz!

  # Statement start timestamp for tx in which audited event occurred
  action_tstamp_stm: timestamptz!

  # Transaction start timestamp for tx in which audited event occurred
  action_tstamp_tx: timestamptz!

  # Application name set when this audit event occurred. Can be changed in-session by client.
  application_name: String

  # New values of fields changed by UPDATE. Null except for row-level UPDATE events.
  changed_fields(
    # JSON select path
    path: String
  ): jsonb

  # IP address of client that issued query. Null for unix domain socket.
  client_addr: inet

  # Remote peer IP port address of client that issued query. Undefined for unix socket.
  client_port: Int

  # Top-level query that caused this auditable event. May be more than one statement.
  client_query: String

  # Unique identifier for each auditable event
  event_id: bigint!
  hasura_user(
    # JSON select path
    path: String
  ): jsonb
  id: ID!

  # Table OID. Changes with drop/create. Get with 'tablename'::regclass
  relid: oid!

  # Record value. Null for statement-level trigger. For INSERT this is the new
  # tuple. For DELETE and UPDATE it is the old tuple.
  row_data(
    # JSON select path
    path: String
  ): jsonb

  # Database schema audited table for this event is in
  schema_name: String!

  # Login / session user whose statement caused the audited event
  session_user_name: String

  # 't' if audit event is from an FOR EACH STATEMENT trigger, 'f' for FOR EACH ROW
  statement_only: Boolean!

  # Non-schema-qualified table name of table event occured in
  table_name: String!

  # Identifier of transaction that made the change. May wrap, but unique paired with action_tstamp_tx.
  transaction_id: bigint
}

# aggregated selection of "audit.logged_actions"
type audit_logged_actions_aggregate {
  aggregate: audit_logged_actions_aggregate_fields
  nodes: [audit_logged_actions!]!
}

# aggregate fields of "audit.logged_actions"
type audit_logged_actions_aggregate_fields {
  avg: audit_logged_actions_avg_fields
  count(columns: [audit_logged_actions_select_column!], distinct: Boolean): Int
  max: audit_logged_actions_max_fields
  min: audit_logged_actions_min_fields
  stddev: audit_logged_actions_stddev_fields
  stddev_pop: audit_logged_actions_stddev_pop_fields
  stddev_samp: audit_logged_actions_stddev_samp_fields
  sum: audit_logged_actions_sum_fields
  var_pop: audit_logged_actions_var_pop_fields
  var_samp: audit_logged_actions_var_samp_fields
  variance: audit_logged_actions_variance_fields
}

# order by aggregate values of table "audit.logged_actions"
input audit_logged_actions_aggregate_order_by {
  avg: audit_logged_actions_avg_order_by
  count: order_by
  max: audit_logged_actions_max_order_by
  min: audit_logged_actions_min_order_by
  stddev: audit_logged_actions_stddev_order_by
  stddev_pop: audit_logged_actions_stddev_pop_order_by
  stddev_samp: audit_logged_actions_stddev_samp_order_by
  sum: audit_logged_actions_sum_order_by
  var_pop: audit_logged_actions_var_pop_order_by
  var_samp: audit_logged_actions_var_samp_order_by
  variance: audit_logged_actions_variance_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input audit_logged_actions_append_input {
  changed_fields: jsonb
  hasura_user: jsonb
  row_data: jsonb
}

# input type for inserting array relation for remote table "audit.logged_actions"
input audit_logged_actions_arr_rel_insert_input {
  data: [audit_logged_actions_insert_input!]!
  on_conflict: audit_logged_actions_on_conflict
}

# aggregate avg on columns
type audit_logged_actions_avg_fields {
  client_port: Float
  event_id: Float
  transaction_id: Float
}

# order by avg() on columns of table "audit.logged_actions"
input audit_logged_actions_avg_order_by {
  client_port: order_by
  event_id: order_by
  transaction_id: order_by
}

# Boolean expression to filter rows from the table "audit.logged_actions". All fields are combined with a logical 'AND'.
input audit_logged_actions_bool_exp {
  _and: [audit_logged_actions_bool_exp]
  _not: audit_logged_actions_bool_exp
  _or: [audit_logged_actions_bool_exp]
  action: String_comparison_exp
  action_tstamp_clk: timestamptz_comparison_exp
  action_tstamp_stm: timestamptz_comparison_exp
  action_tstamp_tx: timestamptz_comparison_exp
  application_name: String_comparison_exp
  changed_fields: jsonb_comparison_exp
  client_addr: inet_comparison_exp
  client_port: Int_comparison_exp
  client_query: String_comparison_exp
  event_id: bigint_comparison_exp
  hasura_user: jsonb_comparison_exp
  relid: oid_comparison_exp
  row_data: jsonb_comparison_exp
  schema_name: String_comparison_exp
  session_user_name: String_comparison_exp
  statement_only: Boolean_comparison_exp
  table_name: String_comparison_exp
  transaction_id: bigint_comparison_exp
}

# unique or primary key constraints on table "audit.logged_actions"
enum audit_logged_actions_constraint {
  # unique or primary key constraint
  logged_actions_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input audit_logged_actions_delete_at_path_input {
  changed_fields: [String]
  hasura_user: [String]
  row_data: [String]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input audit_logged_actions_delete_elem_input {
  changed_fields: Int
  hasura_user: Int
  row_data: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input audit_logged_actions_delete_key_input {
  changed_fields: String
  hasura_user: String
  row_data: String
}

# input type for incrementing integer column in table "audit.logged_actions"
input audit_logged_actions_inc_input {
  client_port: Int
  event_id: bigint
  transaction_id: bigint
}

# input type for inserting data into table "audit.logged_actions"
input audit_logged_actions_insert_input {
  action: String
  action_tstamp_clk: timestamptz
  action_tstamp_stm: timestamptz
  action_tstamp_tx: timestamptz
  application_name: String
  changed_fields: jsonb
  client_addr: inet
  client_port: Int
  client_query: String
  event_id: bigint
  hasura_user: jsonb
  relid: oid
  row_data: jsonb
  schema_name: String
  session_user_name: String
  statement_only: Boolean
  table_name: String
  transaction_id: bigint
}

# aggregate max on columns
type audit_logged_actions_max_fields {
  action: String
  action_tstamp_clk: timestamptz
  action_tstamp_stm: timestamptz
  action_tstamp_tx: timestamptz
  application_name: String
  client_port: Int
  client_query: String
  event_id: bigint
  schema_name: String
  session_user_name: String
  table_name: String
  transaction_id: bigint
}

# order by max() on columns of table "audit.logged_actions"
input audit_logged_actions_max_order_by {
  action: order_by
  action_tstamp_clk: order_by
  action_tstamp_stm: order_by
  action_tstamp_tx: order_by
  application_name: order_by
  client_port: order_by
  client_query: order_by
  event_id: order_by
  schema_name: order_by
  session_user_name: order_by
  table_name: order_by
  transaction_id: order_by
}

# aggregate min on columns
type audit_logged_actions_min_fields {
  action: String
  action_tstamp_clk: timestamptz
  action_tstamp_stm: timestamptz
  action_tstamp_tx: timestamptz
  application_name: String
  client_port: Int
  client_query: String
  event_id: bigint
  schema_name: String
  session_user_name: String
  table_name: String
  transaction_id: bigint
}

# order by min() on columns of table "audit.logged_actions"
input audit_logged_actions_min_order_by {
  action: order_by
  action_tstamp_clk: order_by
  action_tstamp_stm: order_by
  action_tstamp_tx: order_by
  application_name: order_by
  client_port: order_by
  client_query: order_by
  event_id: order_by
  schema_name: order_by
  session_user_name: order_by
  table_name: order_by
  transaction_id: order_by
}

# response of any mutation on the table "audit.logged_actions"
type audit_logged_actions_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [audit_logged_actions!]!
}

# input type for inserting object relation for remote table "audit.logged_actions"
input audit_logged_actions_obj_rel_insert_input {
  data: audit_logged_actions_insert_input!
  on_conflict: audit_logged_actions_on_conflict
}

# on conflict condition type for table "audit.logged_actions"
input audit_logged_actions_on_conflict {
  constraint: audit_logged_actions_constraint!
  update_columns: [audit_logged_actions_update_column!]!
  where: audit_logged_actions_bool_exp
}

# ordering options when selecting data from "audit.logged_actions"
input audit_logged_actions_order_by {
  action: order_by
  action_tstamp_clk: order_by
  action_tstamp_stm: order_by
  action_tstamp_tx: order_by
  application_name: order_by
  changed_fields: order_by
  client_addr: order_by
  client_port: order_by
  client_query: order_by
  event_id: order_by
  hasura_user: order_by
  relid: order_by
  row_data: order_by
  schema_name: order_by
  session_user_name: order_by
  statement_only: order_by
  table_name: order_by
  transaction_id: order_by
}

# primary key columns input for table: "audit.logged_actions"
input audit_logged_actions_pk_columns_input {
  # Unique identifier for each auditable event
  event_id: bigint!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input audit_logged_actions_prepend_input {
  changed_fields: jsonb
  hasura_user: jsonb
  row_data: jsonb
}

# select columns of table "audit.logged_actions"
enum audit_logged_actions_select_column {
  # column name
  action

  # column name
  action_tstamp_clk

  # column name
  action_tstamp_stm

  # column name
  action_tstamp_tx

  # column name
  application_name

  # column name
  changed_fields

  # column name
  client_addr

  # column name
  client_port

  # column name
  client_query

  # column name
  event_id

  # column name
  hasura_user

  # column name
  relid

  # column name
  row_data

  # column name
  schema_name

  # column name
  session_user_name

  # column name
  statement_only

  # column name
  table_name

  # column name
  transaction_id
}

# input type for updating data in table "audit.logged_actions"
input audit_logged_actions_set_input {
  action: String
  action_tstamp_clk: timestamptz
  action_tstamp_stm: timestamptz
  action_tstamp_tx: timestamptz
  application_name: String
  changed_fields: jsonb
  client_addr: inet
  client_port: Int
  client_query: String
  event_id: bigint
  hasura_user: jsonb
  relid: oid
  row_data: jsonb
  schema_name: String
  session_user_name: String
  statement_only: Boolean
  table_name: String
  transaction_id: bigint
}

# aggregate stddev on columns
type audit_logged_actions_stddev_fields {
  client_port: Float
  event_id: Float
  transaction_id: Float
}

# order by stddev() on columns of table "audit.logged_actions"
input audit_logged_actions_stddev_order_by {
  client_port: order_by
  event_id: order_by
  transaction_id: order_by
}

# aggregate stddev_pop on columns
type audit_logged_actions_stddev_pop_fields {
  client_port: Float
  event_id: Float
  transaction_id: Float
}

# order by stddev_pop() on columns of table "audit.logged_actions"
input audit_logged_actions_stddev_pop_order_by {
  client_port: order_by
  event_id: order_by
  transaction_id: order_by
}

# aggregate stddev_samp on columns
type audit_logged_actions_stddev_samp_fields {
  client_port: Float
  event_id: Float
  transaction_id: Float
}

# order by stddev_samp() on columns of table "audit.logged_actions"
input audit_logged_actions_stddev_samp_order_by {
  client_port: order_by
  event_id: order_by
  transaction_id: order_by
}

# aggregate sum on columns
type audit_logged_actions_sum_fields {
  client_port: Int
  event_id: bigint
  transaction_id: bigint
}

# order by sum() on columns of table "audit.logged_actions"
input audit_logged_actions_sum_order_by {
  client_port: order_by
  event_id: order_by
  transaction_id: order_by
}

# update columns of table "audit.logged_actions"
enum audit_logged_actions_update_column {
  # column name
  action

  # column name
  action_tstamp_clk

  # column name
  action_tstamp_stm

  # column name
  action_tstamp_tx

  # column name
  application_name

  # column name
  changed_fields

  # column name
  client_addr

  # column name
  client_port

  # column name
  client_query

  # column name
  event_id

  # column name
  hasura_user

  # column name
  relid

  # column name
  row_data

  # column name
  schema_name

  # column name
  session_user_name

  # column name
  statement_only

  # column name
  table_name

  # column name
  transaction_id
}

# aggregate var_pop on columns
type audit_logged_actions_var_pop_fields {
  client_port: Float
  event_id: Float
  transaction_id: Float
}

# order by var_pop() on columns of table "audit.logged_actions"
input audit_logged_actions_var_pop_order_by {
  client_port: order_by
  event_id: order_by
  transaction_id: order_by
}

# aggregate var_samp on columns
type audit_logged_actions_var_samp_fields {
  client_port: Float
  event_id: Float
  transaction_id: Float
}

# order by var_samp() on columns of table "audit.logged_actions"
input audit_logged_actions_var_samp_order_by {
  client_port: order_by
  event_id: order_by
  transaction_id: order_by
}

# aggregate variance on columns
type audit_logged_actions_variance_fields {
  client_port: Float
  event_id: Float
  transaction_id: Float
}

# order by variance() on columns of table "audit.logged_actions"
input audit_logged_actions_variance_order_by {
  client_port: order_by
  event_id: order_by
  transaction_id: order_by
}

# A Relay Connection object on "audit.logged_actions"
type audit_logged_actionsConnection {
  edges: [audit_logged_actionsEdge!]!
  pageInfo: PageInfo!
}

type audit_logged_actionsEdge {
  cursor: String!
  node: audit_logged_actions!
}

scalar bigint

# expression to compare columns of type bigint. All fields are combined with logical 'AND'.
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

# expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

scalar bpchar

# expression to compare columns of type bpchar. All fields are combined with logical 'AND'.
input bpchar_comparison_exp {
  _eq: bpchar
  _gt: bpchar
  _gte: bpchar
  _in: [bpchar!]
  _is_null: Boolean
  _lt: bpchar
  _lte: bpchar
  _neq: bpchar
  _nin: [bpchar!]
}

scalar bytea

# expression to compare columns of type bytea. All fields are combined with logical 'AND'.
input bytea_comparison_exp {
  _eq: bytea
  _gt: bytea
  _gte: bytea
  _in: [bytea!]
  _is_null: Boolean
  _lt: bytea
  _lte: bytea
  _neq: bytea
  _nin: [bytea!]
}

# columns and relationships of "cpf.annotation_categories"
type cpf_annotation_categories implements Node {
  # An array relationship
  annotations(
    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): [cpf_annotations!]!

  # An aggregated array relationship
  annotations_aggregate(
    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotations_aggregate!

  # An array relationship connection
  annotations_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotationsConnection!
  comment: String!
  id: ID!
}

# aggregated selection of "cpf.annotation_categories"
type cpf_annotation_categories_aggregate {
  aggregate: cpf_annotation_categories_aggregate_fields
  nodes: [cpf_annotation_categories!]!
}

# aggregate fields of "cpf.annotation_categories"
type cpf_annotation_categories_aggregate_fields {
  count(columns: [cpf_annotation_categories_select_column!], distinct: Boolean): Int
  max: cpf_annotation_categories_max_fields
  min: cpf_annotation_categories_min_fields
}

# order by aggregate values of table "cpf.annotation_categories"
input cpf_annotation_categories_aggregate_order_by {
  count: order_by
  max: cpf_annotation_categories_max_order_by
  min: cpf_annotation_categories_min_order_by
}

# input type for inserting array relation for remote table "cpf.annotation_categories"
input cpf_annotation_categories_arr_rel_insert_input {
  data: [cpf_annotation_categories_insert_input!]!
  on_conflict: cpf_annotation_categories_on_conflict
}

# Boolean expression to filter rows from the table "cpf.annotation_categories". All fields are combined with a logical 'AND'.
input cpf_annotation_categories_bool_exp {
  _and: [cpf_annotation_categories_bool_exp]
  _not: cpf_annotation_categories_bool_exp
  _or: [cpf_annotation_categories_bool_exp]
  annotations: cpf_annotations_bool_exp
  comment: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "cpf.annotation_categories"
enum cpf_annotation_categories_constraint {
  # unique or primary key constraint
  annotation_categories_pkey
}

enum cpf_annotation_categories_enum {
  email
  phone
}

# expression to compare columns of type cpf_annotation_categories_enum. All fields are combined with logical 'AND'.
input cpf_annotation_categories_enum_comparison_exp {
  _eq: cpf_annotation_categories_enum
  _in: [cpf_annotation_categories_enum!]
  _is_null: Boolean
  _neq: cpf_annotation_categories_enum
  _nin: [cpf_annotation_categories_enum!]
}

# input type for inserting data into table "cpf.annotation_categories"
input cpf_annotation_categories_insert_input {
  annotations: cpf_annotations_arr_rel_insert_input
  comment: String
  id: String
}

# aggregate max on columns
type cpf_annotation_categories_max_fields {
  comment: String
  id: String
}

# order by max() on columns of table "cpf.annotation_categories"
input cpf_annotation_categories_max_order_by {
  comment: order_by
  id: order_by
}

# aggregate min on columns
type cpf_annotation_categories_min_fields {
  comment: String
  id: String
}

# order by min() on columns of table "cpf.annotation_categories"
input cpf_annotation_categories_min_order_by {
  comment: order_by
  id: order_by
}

# response of any mutation on the table "cpf.annotation_categories"
type cpf_annotation_categories_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_annotation_categories!]!
}

# input type for inserting object relation for remote table "cpf.annotation_categories"
input cpf_annotation_categories_obj_rel_insert_input {
  data: cpf_annotation_categories_insert_input!
  on_conflict: cpf_annotation_categories_on_conflict
}

# on conflict condition type for table "cpf.annotation_categories"
input cpf_annotation_categories_on_conflict {
  constraint: cpf_annotation_categories_constraint!
  update_columns: [cpf_annotation_categories_update_column!]!
  where: cpf_annotation_categories_bool_exp
}

# ordering options when selecting data from "cpf.annotation_categories"
input cpf_annotation_categories_order_by {
  annotations_aggregate: cpf_annotations_aggregate_order_by
  comment: order_by
  id: order_by
}

# primary key columns input for table: "cpf.annotation_categories"
input cpf_annotation_categories_pk_columns_input {
  id: String!
}

# select columns of table "cpf.annotation_categories"
enum cpf_annotation_categories_select_column {
  # column name
  comment

  # column name
  id
}

# input type for updating data in table "cpf.annotation_categories"
input cpf_annotation_categories_set_input {
  comment: String
  id: String
}

# update columns of table "cpf.annotation_categories"
enum cpf_annotation_categories_update_column {
  # column name
  comment

  # column name
  id
}

# A Relay Connection object on "cpf.annotation_categories"
type cpf_annotation_categoriesConnection {
  edges: [cpf_annotation_categoriesEdge!]!
  pageInfo: PageInfo!
}

type cpf_annotation_categoriesEdge {
  cursor: String!
  node: cpf_annotation_categories!
}

# columns and relationships of "cpf.annotations"
type cpf_annotations implements Node {
  # An object relationship
  annotation_category: cpf_annotation_categories!
  category: cpf_annotation_categories_enum!
  comment: String!
  created_at: timestamptz!

  # An object relationship
  custom_forms_library: cpf_custom_forms_library!

  # An object relationship
  custom_forms_library_by_period: cpf_custom_forms_library_file_versions!
  custom_forms_library_by_period_id: uuid!
  custom_forms_library_id: uuid!

  # An object relationship
  customer: cpf_customers!
  customer_id: uuid!
  display_datetime: timestamptz!
  id: ID!

  # An object relationship
  package: cpf_packages!
  package_id: uuid!

  # An object relationship
  package_request: cpf_package_requests!
  package_request_id: uuid!

  # An object relationship
  package_response: cpf_package_responses!
  package_response_id: uuid!

  # An object relationship
  region: cpf_regions!
  region_id: uuid!

  # An object relationship
  tenant: cpf_tenants!
  tenant_id: uuid!
  updated_at: timestamptz!
  user: uuid!

  # An object relationship
  userByUser: cpf_users!
}

# aggregated selection of "cpf.annotations"
type cpf_annotations_aggregate {
  aggregate: cpf_annotations_aggregate_fields
  nodes: [cpf_annotations!]!
}

# aggregate fields of "cpf.annotations"
type cpf_annotations_aggregate_fields {
  count(columns: [cpf_annotations_select_column!], distinct: Boolean): Int
  max: cpf_annotations_max_fields
  min: cpf_annotations_min_fields
}

# order by aggregate values of table "cpf.annotations"
input cpf_annotations_aggregate_order_by {
  count: order_by
  max: cpf_annotations_max_order_by
  min: cpf_annotations_min_order_by
}

# input type for inserting array relation for remote table "cpf.annotations"
input cpf_annotations_arr_rel_insert_input {
  data: [cpf_annotations_insert_input!]!
  on_conflict: cpf_annotations_on_conflict
}

# Boolean expression to filter rows from the table "cpf.annotations". All fields are combined with a logical 'AND'.
input cpf_annotations_bool_exp {
  _and: [cpf_annotations_bool_exp]
  _not: cpf_annotations_bool_exp
  _or: [cpf_annotations_bool_exp]
  annotation_category: cpf_annotation_categories_bool_exp
  category: cpf_annotation_categories_enum_comparison_exp
  comment: String_comparison_exp
  created_at: timestamptz_comparison_exp
  custom_forms_library: cpf_custom_forms_library_bool_exp
  custom_forms_library_by_period: cpf_custom_forms_library_file_versions_bool_exp
  custom_forms_library_by_period_id: uuid_comparison_exp
  custom_forms_library_id: uuid_comparison_exp
  customer: cpf_customers_bool_exp
  customer_id: uuid_comparison_exp
  display_datetime: timestamptz_comparison_exp
  id: uuid_comparison_exp
  package: cpf_packages_bool_exp
  package_id: uuid_comparison_exp
  package_request: cpf_package_requests_bool_exp
  package_request_id: uuid_comparison_exp
  package_response: cpf_package_responses_bool_exp
  package_response_id: uuid_comparison_exp
  region: cpf_regions_bool_exp
  region_id: uuid_comparison_exp
  tenant: cpf_tenants_bool_exp
  tenant_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: uuid_comparison_exp
  userByUser: cpf_users_bool_exp
}

# unique or primary key constraints on table "cpf.annotations"
enum cpf_annotations_constraint {
  # unique or primary key constraint
  annotations_pkey
}

# input type for inserting data into table "cpf.annotations"
input cpf_annotations_insert_input {
  annotation_category: cpf_annotation_categories_obj_rel_insert_input
  category: cpf_annotation_categories_enum
  comment: String
  created_at: timestamptz
  custom_forms_library: cpf_custom_forms_library_obj_rel_insert_input
  custom_forms_library_by_period: cpf_custom_forms_library_file_versions_obj_rel_insert_input
  custom_forms_library_by_period_id: uuid
  custom_forms_library_id: uuid
  customer: cpf_customers_obj_rel_insert_input
  customer_id: uuid
  display_datetime: timestamptz
  id: uuid
  package: cpf_packages_obj_rel_insert_input
  package_id: uuid
  package_request: cpf_package_requests_obj_rel_insert_input
  package_request_id: uuid
  package_response: cpf_package_responses_obj_rel_insert_input
  package_response_id: uuid
  region: cpf_regions_obj_rel_insert_input
  region_id: uuid
  tenant: cpf_tenants_obj_rel_insert_input
  tenant_id: uuid
  updated_at: timestamptz
  user: uuid
  userByUser: cpf_users_obj_rel_insert_input
}

# aggregate max on columns
type cpf_annotations_max_fields {
  comment: String
  created_at: timestamptz
  custom_forms_library_by_period_id: uuid
  custom_forms_library_id: uuid
  customer_id: uuid
  display_datetime: timestamptz
  id: uuid
  package_id: uuid
  package_request_id: uuid
  package_response_id: uuid
  region_id: uuid
  tenant_id: uuid
  updated_at: timestamptz
  user: uuid
}

# order by max() on columns of table "cpf.annotations"
input cpf_annotations_max_order_by {
  comment: order_by
  created_at: order_by
  custom_forms_library_by_period_id: order_by
  custom_forms_library_id: order_by
  customer_id: order_by
  display_datetime: order_by
  id: order_by
  package_id: order_by
  package_request_id: order_by
  package_response_id: order_by
  region_id: order_by
  tenant_id: order_by
  updated_at: order_by
  user: order_by
}

# aggregate min on columns
type cpf_annotations_min_fields {
  comment: String
  created_at: timestamptz
  custom_forms_library_by_period_id: uuid
  custom_forms_library_id: uuid
  customer_id: uuid
  display_datetime: timestamptz
  id: uuid
  package_id: uuid
  package_request_id: uuid
  package_response_id: uuid
  region_id: uuid
  tenant_id: uuid
  updated_at: timestamptz
  user: uuid
}

# order by min() on columns of table "cpf.annotations"
input cpf_annotations_min_order_by {
  comment: order_by
  created_at: order_by
  custom_forms_library_by_period_id: order_by
  custom_forms_library_id: order_by
  customer_id: order_by
  display_datetime: order_by
  id: order_by
  package_id: order_by
  package_request_id: order_by
  package_response_id: order_by
  region_id: order_by
  tenant_id: order_by
  updated_at: order_by
  user: order_by
}

# response of any mutation on the table "cpf.annotations"
type cpf_annotations_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_annotations!]!
}

# input type for inserting object relation for remote table "cpf.annotations"
input cpf_annotations_obj_rel_insert_input {
  data: cpf_annotations_insert_input!
  on_conflict: cpf_annotations_on_conflict
}

# on conflict condition type for table "cpf.annotations"
input cpf_annotations_on_conflict {
  constraint: cpf_annotations_constraint!
  update_columns: [cpf_annotations_update_column!]!
  where: cpf_annotations_bool_exp
}

# ordering options when selecting data from "cpf.annotations"
input cpf_annotations_order_by {
  annotation_category: cpf_annotation_categories_order_by
  category: order_by
  comment: order_by
  created_at: order_by
  custom_forms_library: cpf_custom_forms_library_order_by
  custom_forms_library_by_period: cpf_custom_forms_library_file_versions_order_by
  custom_forms_library_by_period_id: order_by
  custom_forms_library_id: order_by
  customer: cpf_customers_order_by
  customer_id: order_by
  display_datetime: order_by
  id: order_by
  package: cpf_packages_order_by
  package_id: order_by
  package_request: cpf_package_requests_order_by
  package_request_id: order_by
  package_response: cpf_package_responses_order_by
  package_response_id: order_by
  region: cpf_regions_order_by
  region_id: order_by
  tenant: cpf_tenants_order_by
  tenant_id: order_by
  updated_at: order_by
  user: order_by
  userByUser: cpf_users_order_by
}

# primary key columns input for table: "cpf.annotations"
input cpf_annotations_pk_columns_input {
  id: uuid!
}

# select columns of table "cpf.annotations"
enum cpf_annotations_select_column {
  # column name
  category

  # column name
  comment

  # column name
  created_at

  # column name
  custom_forms_library_by_period_id

  # column name
  custom_forms_library_id

  # column name
  customer_id

  # column name
  display_datetime

  # column name
  id

  # column name
  package_id

  # column name
  package_request_id

  # column name
  package_response_id

  # column name
  region_id

  # column name
  tenant_id

  # column name
  updated_at

  # column name
  user
}

# input type for updating data in table "cpf.annotations"
input cpf_annotations_set_input {
  category: cpf_annotation_categories_enum
  comment: String
  created_at: timestamptz
  custom_forms_library_by_period_id: uuid
  custom_forms_library_id: uuid
  customer_id: uuid
  display_datetime: timestamptz
  id: uuid
  package_id: uuid
  package_request_id: uuid
  package_response_id: uuid
  region_id: uuid
  tenant_id: uuid
  updated_at: timestamptz
  user: uuid
}

# update columns of table "cpf.annotations"
enum cpf_annotations_update_column {
  # column name
  category

  # column name
  comment

  # column name
  created_at

  # column name
  custom_forms_library_by_period_id

  # column name
  custom_forms_library_id

  # column name
  customer_id

  # column name
  display_datetime

  # column name
  id

  # column name
  package_id

  # column name
  package_request_id

  # column name
  package_response_id

  # column name
  region_id

  # column name
  tenant_id

  # column name
  updated_at

  # column name
  user
}

# A Relay Connection object on "cpf.annotations"
type cpf_annotationsConnection {
  edges: [cpf_annotationsEdge!]!
  pageInfo: PageInfo!
}

type cpf_annotationsEdge {
  cursor: String!
  node: cpf_annotations!
}

# columns and relationships of "cpf.custom_forms_library"
type cpf_custom_forms_library implements Node {
  # An array relationship
  annotations(
    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): [cpf_annotations!]!

  # An aggregated array relationship
  annotations_aggregate(
    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotations_aggregate!

  # An array relationship connection
  annotations_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotationsConnection!
  created_at: timestamptz!

  # An array relationship
  custom_forms_library_by_periods(
    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_file_versions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_file_versions_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_file_versions_bool_exp
  ): [cpf_custom_forms_library_file_versions!]!

  # An aggregated array relationship
  custom_forms_library_by_periods_aggregate(
    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_file_versions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_file_versions_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_file_versions_bool_exp
  ): cpf_custom_forms_library_file_versions_aggregate!

  # An array relationship connection
  custom_forms_library_by_periods_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_file_versions_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_file_versions_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_file_versions_bool_exp
  ): cpf_custom_forms_library_file_versionsConnection!

  # An array relationship
  custom_forms_library_regions(
    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_regions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_regions_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_regions_bool_exp
  ): [cpf_custom_forms_library_regions!]!

  # An aggregated array relationship
  custom_forms_library_regions_aggregate(
    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_regions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_regions_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_regions_bool_exp
  ): cpf_custom_forms_library_regions_aggregate!

  # An array relationship connection
  custom_forms_library_regions_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_regions_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_regions_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_regions_bool_exp
  ): cpf_custom_forms_library_regionsConnection!

  # An array relationship
  custom_forms_library_tax_types(
    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_tax_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_tax_types_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_tax_types_bool_exp
  ): [cpf_custom_forms_library_tax_types!]!

  # An aggregated array relationship
  custom_forms_library_tax_types_aggregate(
    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_tax_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_tax_types_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_tax_types_bool_exp
  ): cpf_custom_forms_library_tax_types_aggregate!

  # An array relationship connection
  custom_forms_library_tax_types_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_tax_types_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_tax_types_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_tax_types_bool_exp
  ): cpf_custom_forms_library_tax_typesConnection!
  id: ID!
  level: cpf_level_enum!

  # An object relationship
  levelByLevel: cpf_level!
  name: String!
  tenant_id: uuid!
  updated_at: timestamptz!
}

# aggregated selection of "cpf.custom_forms_library"
type cpf_custom_forms_library_aggregate {
  aggregate: cpf_custom_forms_library_aggregate_fields
  nodes: [cpf_custom_forms_library!]!
}

# aggregate fields of "cpf.custom_forms_library"
type cpf_custom_forms_library_aggregate_fields {
  count(columns: [cpf_custom_forms_library_select_column!], distinct: Boolean): Int
  max: cpf_custom_forms_library_max_fields
  min: cpf_custom_forms_library_min_fields
}

# order by aggregate values of table "cpf.custom_forms_library"
input cpf_custom_forms_library_aggregate_order_by {
  count: order_by
  max: cpf_custom_forms_library_max_order_by
  min: cpf_custom_forms_library_min_order_by
}

# input type for inserting array relation for remote table "cpf.custom_forms_library"
input cpf_custom_forms_library_arr_rel_insert_input {
  data: [cpf_custom_forms_library_insert_input!]!
  on_conflict: cpf_custom_forms_library_on_conflict
}

# Boolean expression to filter rows from the table "cpf.custom_forms_library". All fields are combined with a logical 'AND'.
input cpf_custom_forms_library_bool_exp {
  _and: [cpf_custom_forms_library_bool_exp]
  _not: cpf_custom_forms_library_bool_exp
  _or: [cpf_custom_forms_library_bool_exp]
  annotations: cpf_annotations_bool_exp
  created_at: timestamptz_comparison_exp
  custom_forms_library_by_periods: cpf_custom_forms_library_file_versions_bool_exp
  custom_forms_library_regions: cpf_custom_forms_library_regions_bool_exp
  custom_forms_library_tax_types: cpf_custom_forms_library_tax_types_bool_exp
  id: uuid_comparison_exp
  level: cpf_level_enum_comparison_exp
  levelByLevel: cpf_level_bool_exp
  name: String_comparison_exp
  tenant_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "cpf.custom_forms_library"
enum cpf_custom_forms_library_constraint {
  # unique or primary key constraint
  custom_forms_library_pkey
}

# columns and relationships of "cpf.custom_forms_library_file_versions"
type cpf_custom_forms_library_file_versions implements Node {
  # An array relationship
  annotations(
    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): [cpf_annotations!]!

  # An aggregated array relationship
  annotations_aggregate(
    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotations_aggregate!

  # An array relationship connection
  annotations_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotationsConnection!
  created_at: timestamptz!

  # An object relationship
  custom_forms_library: cpf_custom_forms_library!
  custom_forms_library_id: uuid!
  effective_date: date
  expiration_date: date
  file: bytea!
  id: ID!
  updated_at: timestamptz!
  uploaded_by: uuid
  uploaded_date: timestamptz
}

# aggregated selection of "cpf.custom_forms_library_file_versions"
type cpf_custom_forms_library_file_versions_aggregate {
  aggregate: cpf_custom_forms_library_file_versions_aggregate_fields
  nodes: [cpf_custom_forms_library_file_versions!]!
}

# aggregate fields of "cpf.custom_forms_library_file_versions"
type cpf_custom_forms_library_file_versions_aggregate_fields {
  count(columns: [cpf_custom_forms_library_file_versions_select_column!], distinct: Boolean): Int
  max: cpf_custom_forms_library_file_versions_max_fields
  min: cpf_custom_forms_library_file_versions_min_fields
}

# order by aggregate values of table "cpf.custom_forms_library_file_versions"
input cpf_custom_forms_library_file_versions_aggregate_order_by {
  count: order_by
  max: cpf_custom_forms_library_file_versions_max_order_by
  min: cpf_custom_forms_library_file_versions_min_order_by
}

# input type for inserting array relation for remote table "cpf.custom_forms_library_file_versions"
input cpf_custom_forms_library_file_versions_arr_rel_insert_input {
  data: [cpf_custom_forms_library_file_versions_insert_input!]!
  on_conflict: cpf_custom_forms_library_file_versions_on_conflict
}

# Boolean expression to filter rows from the table
# "cpf.custom_forms_library_file_versions". All fields are combined with a logical 'AND'.
input cpf_custom_forms_library_file_versions_bool_exp {
  _and: [cpf_custom_forms_library_file_versions_bool_exp]
  _not: cpf_custom_forms_library_file_versions_bool_exp
  _or: [cpf_custom_forms_library_file_versions_bool_exp]
  annotations: cpf_annotations_bool_exp
  created_at: timestamptz_comparison_exp
  custom_forms_library: cpf_custom_forms_library_bool_exp
  custom_forms_library_id: uuid_comparison_exp
  effective_date: date_comparison_exp
  expiration_date: date_comparison_exp
  file: bytea_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  uploaded_by: uuid_comparison_exp
  uploaded_date: timestamptz_comparison_exp
}

# unique or primary key constraints on table "cpf.custom_forms_library_file_versions"
enum cpf_custom_forms_library_file_versions_constraint {
  # unique or primary key constraint
  custom_forms_library_by_period_pkey
}

# input type for inserting data into table "cpf.custom_forms_library_file_versions"
input cpf_custom_forms_library_file_versions_insert_input {
  annotations: cpf_annotations_arr_rel_insert_input
  created_at: timestamptz
  custom_forms_library: cpf_custom_forms_library_obj_rel_insert_input
  custom_forms_library_id: uuid
  effective_date: date
  expiration_date: date
  file: bytea
  id: uuid
  updated_at: timestamptz
  uploaded_by: uuid
  uploaded_date: timestamptz
}

# aggregate max on columns
type cpf_custom_forms_library_file_versions_max_fields {
  created_at: timestamptz
  custom_forms_library_id: uuid
  effective_date: date
  expiration_date: date
  id: uuid
  updated_at: timestamptz
  uploaded_by: uuid
  uploaded_date: timestamptz
}

# order by max() on columns of table "cpf.custom_forms_library_file_versions"
input cpf_custom_forms_library_file_versions_max_order_by {
  created_at: order_by
  custom_forms_library_id: order_by
  effective_date: order_by
  expiration_date: order_by
  id: order_by
  updated_at: order_by
  uploaded_by: order_by
  uploaded_date: order_by
}

# aggregate min on columns
type cpf_custom_forms_library_file_versions_min_fields {
  created_at: timestamptz
  custom_forms_library_id: uuid
  effective_date: date
  expiration_date: date
  id: uuid
  updated_at: timestamptz
  uploaded_by: uuid
  uploaded_date: timestamptz
}

# order by min() on columns of table "cpf.custom_forms_library_file_versions"
input cpf_custom_forms_library_file_versions_min_order_by {
  created_at: order_by
  custom_forms_library_id: order_by
  effective_date: order_by
  expiration_date: order_by
  id: order_by
  updated_at: order_by
  uploaded_by: order_by
  uploaded_date: order_by
}

# response of any mutation on the table "cpf.custom_forms_library_file_versions"
type cpf_custom_forms_library_file_versions_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_custom_forms_library_file_versions!]!
}

# input type for inserting object relation for remote table "cpf.custom_forms_library_file_versions"
input cpf_custom_forms_library_file_versions_obj_rel_insert_input {
  data: cpf_custom_forms_library_file_versions_insert_input!
  on_conflict: cpf_custom_forms_library_file_versions_on_conflict
}

# on conflict condition type for table "cpf.custom_forms_library_file_versions"
input cpf_custom_forms_library_file_versions_on_conflict {
  constraint: cpf_custom_forms_library_file_versions_constraint!
  update_columns: [cpf_custom_forms_library_file_versions_update_column!]!
  where: cpf_custom_forms_library_file_versions_bool_exp
}

# ordering options when selecting data from "cpf.custom_forms_library_file_versions"
input cpf_custom_forms_library_file_versions_order_by {
  annotations_aggregate: cpf_annotations_aggregate_order_by
  created_at: order_by
  custom_forms_library: cpf_custom_forms_library_order_by
  custom_forms_library_id: order_by
  effective_date: order_by
  expiration_date: order_by
  file: order_by
  id: order_by
  updated_at: order_by
  uploaded_by: order_by
  uploaded_date: order_by
}

# primary key columns input for table: "cpf.custom_forms_library_file_versions"
input cpf_custom_forms_library_file_versions_pk_columns_input {
  id: uuid!
}

# select columns of table "cpf.custom_forms_library_file_versions"
enum cpf_custom_forms_library_file_versions_select_column {
  # column name
  created_at

  # column name
  custom_forms_library_id

  # column name
  effective_date

  # column name
  expiration_date

  # column name
  file

  # column name
  id

  # column name
  updated_at

  # column name
  uploaded_by

  # column name
  uploaded_date
}

# input type for updating data in table "cpf.custom_forms_library_file_versions"
input cpf_custom_forms_library_file_versions_set_input {
  created_at: timestamptz
  custom_forms_library_id: uuid
  effective_date: date
  expiration_date: date
  file: bytea
  id: uuid
  updated_at: timestamptz
  uploaded_by: uuid
  uploaded_date: timestamptz
}

# update columns of table "cpf.custom_forms_library_file_versions"
enum cpf_custom_forms_library_file_versions_update_column {
  # column name
  created_at

  # column name
  custom_forms_library_id

  # column name
  effective_date

  # column name
  expiration_date

  # column name
  file

  # column name
  id

  # column name
  updated_at

  # column name
  uploaded_by

  # column name
  uploaded_date
}

# A Relay Connection object on "cpf.custom_forms_library_file_versions"
type cpf_custom_forms_library_file_versionsConnection {
  edges: [cpf_custom_forms_library_file_versionsEdge!]!
  pageInfo: PageInfo!
}

type cpf_custom_forms_library_file_versionsEdge {
  cursor: String!
  node: cpf_custom_forms_library_file_versions!
}

# input type for inserting data into table "cpf.custom_forms_library"
input cpf_custom_forms_library_insert_input {
  annotations: cpf_annotations_arr_rel_insert_input
  created_at: timestamptz
  custom_forms_library_by_periods: cpf_custom_forms_library_file_versions_arr_rel_insert_input
  custom_forms_library_regions: cpf_custom_forms_library_regions_arr_rel_insert_input
  custom_forms_library_tax_types: cpf_custom_forms_library_tax_types_arr_rel_insert_input
  id: uuid
  level: cpf_level_enum
  levelByLevel: cpf_level_obj_rel_insert_input
  name: String
  tenant_id: uuid
  updated_at: timestamptz
}

# aggregate max on columns
type cpf_custom_forms_library_max_fields {
  created_at: timestamptz
  id: uuid
  name: String
  tenant_id: uuid
  updated_at: timestamptz
}

# order by max() on columns of table "cpf.custom_forms_library"
input cpf_custom_forms_library_max_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  tenant_id: order_by
  updated_at: order_by
}

# aggregate min on columns
type cpf_custom_forms_library_min_fields {
  created_at: timestamptz
  id: uuid
  name: String
  tenant_id: uuid
  updated_at: timestamptz
}

# order by min() on columns of table "cpf.custom_forms_library"
input cpf_custom_forms_library_min_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  tenant_id: order_by
  updated_at: order_by
}

# response of any mutation on the table "cpf.custom_forms_library"
type cpf_custom_forms_library_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_custom_forms_library!]!
}

# input type for inserting object relation for remote table "cpf.custom_forms_library"
input cpf_custom_forms_library_obj_rel_insert_input {
  data: cpf_custom_forms_library_insert_input!
  on_conflict: cpf_custom_forms_library_on_conflict
}

# on conflict condition type for table "cpf.custom_forms_library"
input cpf_custom_forms_library_on_conflict {
  constraint: cpf_custom_forms_library_constraint!
  update_columns: [cpf_custom_forms_library_update_column!]!
  where: cpf_custom_forms_library_bool_exp
}

# ordering options when selecting data from "cpf.custom_forms_library"
input cpf_custom_forms_library_order_by {
  annotations_aggregate: cpf_annotations_aggregate_order_by
  created_at: order_by
  custom_forms_library_by_periods_aggregate: cpf_custom_forms_library_file_versions_aggregate_order_by
  custom_forms_library_regions_aggregate: cpf_custom_forms_library_regions_aggregate_order_by
  custom_forms_library_tax_types_aggregate: cpf_custom_forms_library_tax_types_aggregate_order_by
  id: order_by
  level: order_by
  levelByLevel: cpf_level_order_by
  name: order_by
  tenant_id: order_by
  updated_at: order_by
}

# primary key columns input for table: "cpf.custom_forms_library"
input cpf_custom_forms_library_pk_columns_input {
  id: uuid!
}

# columns and relationships of "cpf.custom_forms_library_regions"
type cpf_custom_forms_library_regions implements Node {
  # An object relationship
  custom_forms_library: cpf_custom_forms_library!
  custom_forms_library_id: uuid!
  id: ID!

  # An object relationship
  region: cpf_regions!
  region_id: uuid!
}

# aggregated selection of "cpf.custom_forms_library_regions"
type cpf_custom_forms_library_regions_aggregate {
  aggregate: cpf_custom_forms_library_regions_aggregate_fields
  nodes: [cpf_custom_forms_library_regions!]!
}

# aggregate fields of "cpf.custom_forms_library_regions"
type cpf_custom_forms_library_regions_aggregate_fields {
  count(columns: [cpf_custom_forms_library_regions_select_column!], distinct: Boolean): Int
  max: cpf_custom_forms_library_regions_max_fields
  min: cpf_custom_forms_library_regions_min_fields
}

# order by aggregate values of table "cpf.custom_forms_library_regions"
input cpf_custom_forms_library_regions_aggregate_order_by {
  count: order_by
  max: cpf_custom_forms_library_regions_max_order_by
  min: cpf_custom_forms_library_regions_min_order_by
}

# input type for inserting array relation for remote table "cpf.custom_forms_library_regions"
input cpf_custom_forms_library_regions_arr_rel_insert_input {
  data: [cpf_custom_forms_library_regions_insert_input!]!
  on_conflict: cpf_custom_forms_library_regions_on_conflict
}

# Boolean expression to filter rows from the table
# "cpf.custom_forms_library_regions". All fields are combined with a logical 'AND'.
input cpf_custom_forms_library_regions_bool_exp {
  _and: [cpf_custom_forms_library_regions_bool_exp]
  _not: cpf_custom_forms_library_regions_bool_exp
  _or: [cpf_custom_forms_library_regions_bool_exp]
  custom_forms_library: cpf_custom_forms_library_bool_exp
  custom_forms_library_id: uuid_comparison_exp
  id: uuid_comparison_exp
  region: cpf_regions_bool_exp
  region_id: uuid_comparison_exp
}

# unique or primary key constraints on table "cpf.custom_forms_library_regions"
enum cpf_custom_forms_library_regions_constraint {
  # unique or primary key constraint
  custom_forms_library_regions_pkey
}

# input type for inserting data into table "cpf.custom_forms_library_regions"
input cpf_custom_forms_library_regions_insert_input {
  custom_forms_library: cpf_custom_forms_library_obj_rel_insert_input
  custom_forms_library_id: uuid
  id: uuid
  region: cpf_regions_obj_rel_insert_input
  region_id: uuid
}

# aggregate max on columns
type cpf_custom_forms_library_regions_max_fields {
  custom_forms_library_id: uuid
  id: uuid
  region_id: uuid
}

# order by max() on columns of table "cpf.custom_forms_library_regions"
input cpf_custom_forms_library_regions_max_order_by {
  custom_forms_library_id: order_by
  id: order_by
  region_id: order_by
}

# aggregate min on columns
type cpf_custom_forms_library_regions_min_fields {
  custom_forms_library_id: uuid
  id: uuid
  region_id: uuid
}

# order by min() on columns of table "cpf.custom_forms_library_regions"
input cpf_custom_forms_library_regions_min_order_by {
  custom_forms_library_id: order_by
  id: order_by
  region_id: order_by
}

# response of any mutation on the table "cpf.custom_forms_library_regions"
type cpf_custom_forms_library_regions_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_custom_forms_library_regions!]!
}

# input type for inserting object relation for remote table "cpf.custom_forms_library_regions"
input cpf_custom_forms_library_regions_obj_rel_insert_input {
  data: cpf_custom_forms_library_regions_insert_input!
  on_conflict: cpf_custom_forms_library_regions_on_conflict
}

# on conflict condition type for table "cpf.custom_forms_library_regions"
input cpf_custom_forms_library_regions_on_conflict {
  constraint: cpf_custom_forms_library_regions_constraint!
  update_columns: [cpf_custom_forms_library_regions_update_column!]!
  where: cpf_custom_forms_library_regions_bool_exp
}

# ordering options when selecting data from "cpf.custom_forms_library_regions"
input cpf_custom_forms_library_regions_order_by {
  custom_forms_library: cpf_custom_forms_library_order_by
  custom_forms_library_id: order_by
  id: order_by
  region: cpf_regions_order_by
  region_id: order_by
}

# primary key columns input for table: "cpf.custom_forms_library_regions"
input cpf_custom_forms_library_regions_pk_columns_input {
  id: uuid!
}

# select columns of table "cpf.custom_forms_library_regions"
enum cpf_custom_forms_library_regions_select_column {
  # column name
  custom_forms_library_id

  # column name
  id

  # column name
  region_id
}

# input type for updating data in table "cpf.custom_forms_library_regions"
input cpf_custom_forms_library_regions_set_input {
  custom_forms_library_id: uuid
  id: uuid
  region_id: uuid
}

# update columns of table "cpf.custom_forms_library_regions"
enum cpf_custom_forms_library_regions_update_column {
  # column name
  custom_forms_library_id

  # column name
  id

  # column name
  region_id
}

# A Relay Connection object on "cpf.custom_forms_library_regions"
type cpf_custom_forms_library_regionsConnection {
  edges: [cpf_custom_forms_library_regionsEdge!]!
  pageInfo: PageInfo!
}

type cpf_custom_forms_library_regionsEdge {
  cursor: String!
  node: cpf_custom_forms_library_regions!
}

# select columns of table "cpf.custom_forms_library"
enum cpf_custom_forms_library_select_column {
  # column name
  created_at

  # column name
  id

  # column name
  level

  # column name
  name

  # column name
  tenant_id

  # column name
  updated_at
}

# input type for updating data in table "cpf.custom_forms_library"
input cpf_custom_forms_library_set_input {
  created_at: timestamptz
  id: uuid
  level: cpf_level_enum
  name: String
  tenant_id: uuid
  updated_at: timestamptz
}

# columns and relationships of "cpf.custom_forms_library_tax_types"
type cpf_custom_forms_library_tax_types implements Node {
  # An object relationship
  custom_forms_library: cpf_custom_forms_library!
  custom_forms_library_id: uuid!
  id: ID!

  # An object relationship
  taxTypeByTaxType: cpf_tax_types!
  tax_type: cpf_tax_types_enum!
}

# aggregated selection of "cpf.custom_forms_library_tax_types"
type cpf_custom_forms_library_tax_types_aggregate {
  aggregate: cpf_custom_forms_library_tax_types_aggregate_fields
  nodes: [cpf_custom_forms_library_tax_types!]!
}

# aggregate fields of "cpf.custom_forms_library_tax_types"
type cpf_custom_forms_library_tax_types_aggregate_fields {
  count(columns: [cpf_custom_forms_library_tax_types_select_column!], distinct: Boolean): Int
  max: cpf_custom_forms_library_tax_types_max_fields
  min: cpf_custom_forms_library_tax_types_min_fields
}

# order by aggregate values of table "cpf.custom_forms_library_tax_types"
input cpf_custom_forms_library_tax_types_aggregate_order_by {
  count: order_by
  max: cpf_custom_forms_library_tax_types_max_order_by
  min: cpf_custom_forms_library_tax_types_min_order_by
}

# input type for inserting array relation for remote table "cpf.custom_forms_library_tax_types"
input cpf_custom_forms_library_tax_types_arr_rel_insert_input {
  data: [cpf_custom_forms_library_tax_types_insert_input!]!
  on_conflict: cpf_custom_forms_library_tax_types_on_conflict
}

# Boolean expression to filter rows from the table
# "cpf.custom_forms_library_tax_types". All fields are combined with a logical 'AND'.
input cpf_custom_forms_library_tax_types_bool_exp {
  _and: [cpf_custom_forms_library_tax_types_bool_exp]
  _not: cpf_custom_forms_library_tax_types_bool_exp
  _or: [cpf_custom_forms_library_tax_types_bool_exp]
  custom_forms_library: cpf_custom_forms_library_bool_exp
  custom_forms_library_id: uuid_comparison_exp
  id: uuid_comparison_exp
  taxTypeByTaxType: cpf_tax_types_bool_exp
  tax_type: cpf_tax_types_enum_comparison_exp
}

# unique or primary key constraints on table "cpf.custom_forms_library_tax_types"
enum cpf_custom_forms_library_tax_types_constraint {
  # unique or primary key constraint
  custom_forms_library_tax_types_pkey
}

# input type for inserting data into table "cpf.custom_forms_library_tax_types"
input cpf_custom_forms_library_tax_types_insert_input {
  custom_forms_library: cpf_custom_forms_library_obj_rel_insert_input
  custom_forms_library_id: uuid
  id: uuid
  taxTypeByTaxType: cpf_tax_types_obj_rel_insert_input
  tax_type: cpf_tax_types_enum
}

# aggregate max on columns
type cpf_custom_forms_library_tax_types_max_fields {
  custom_forms_library_id: uuid
  id: uuid
}

# order by max() on columns of table "cpf.custom_forms_library_tax_types"
input cpf_custom_forms_library_tax_types_max_order_by {
  custom_forms_library_id: order_by
  id: order_by
}

# aggregate min on columns
type cpf_custom_forms_library_tax_types_min_fields {
  custom_forms_library_id: uuid
  id: uuid
}

# order by min() on columns of table "cpf.custom_forms_library_tax_types"
input cpf_custom_forms_library_tax_types_min_order_by {
  custom_forms_library_id: order_by
  id: order_by
}

# response of any mutation on the table "cpf.custom_forms_library_tax_types"
type cpf_custom_forms_library_tax_types_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_custom_forms_library_tax_types!]!
}

# input type for inserting object relation for remote table "cpf.custom_forms_library_tax_types"
input cpf_custom_forms_library_tax_types_obj_rel_insert_input {
  data: cpf_custom_forms_library_tax_types_insert_input!
  on_conflict: cpf_custom_forms_library_tax_types_on_conflict
}

# on conflict condition type for table "cpf.custom_forms_library_tax_types"
input cpf_custom_forms_library_tax_types_on_conflict {
  constraint: cpf_custom_forms_library_tax_types_constraint!
  update_columns: [cpf_custom_forms_library_tax_types_update_column!]!
  where: cpf_custom_forms_library_tax_types_bool_exp
}

# ordering options when selecting data from "cpf.custom_forms_library_tax_types"
input cpf_custom_forms_library_tax_types_order_by {
  custom_forms_library: cpf_custom_forms_library_order_by
  custom_forms_library_id: order_by
  id: order_by
  taxTypeByTaxType: cpf_tax_types_order_by
  tax_type: order_by
}

# primary key columns input for table: "cpf.custom_forms_library_tax_types"
input cpf_custom_forms_library_tax_types_pk_columns_input {
  id: uuid!
}

# select columns of table "cpf.custom_forms_library_tax_types"
enum cpf_custom_forms_library_tax_types_select_column {
  # column name
  custom_forms_library_id

  # column name
  id

  # column name
  tax_type
}

# input type for updating data in table "cpf.custom_forms_library_tax_types"
input cpf_custom_forms_library_tax_types_set_input {
  custom_forms_library_id: uuid
  id: uuid
  tax_type: cpf_tax_types_enum
}

# update columns of table "cpf.custom_forms_library_tax_types"
enum cpf_custom_forms_library_tax_types_update_column {
  # column name
  custom_forms_library_id

  # column name
  id

  # column name
  tax_type
}

# A Relay Connection object on "cpf.custom_forms_library_tax_types"
type cpf_custom_forms_library_tax_typesConnection {
  edges: [cpf_custom_forms_library_tax_typesEdge!]!
  pageInfo: PageInfo!
}

type cpf_custom_forms_library_tax_typesEdge {
  cursor: String!
  node: cpf_custom_forms_library_tax_types!
}

# update columns of table "cpf.custom_forms_library"
enum cpf_custom_forms_library_update_column {
  # column name
  created_at

  # column name
  id

  # column name
  level

  # column name
  name

  # column name
  tenant_id

  # column name
  updated_at
}

# A Relay Connection object on "cpf.custom_forms_library"
type cpf_custom_forms_libraryConnection {
  edges: [cpf_custom_forms_libraryEdge!]!
  pageInfo: PageInfo!
}

type cpf_custom_forms_libraryEdge {
  cursor: String!
  node: cpf_custom_forms_library!
}

# columns and relationships of "cpf.customers"
type cpf_customers implements Node {
  address: String

  # An array relationship
  annotations(
    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): [cpf_annotations!]!

  # An aggregated array relationship
  annotations_aggregate(
    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotations_aggregate!

  # An array relationship connection
  annotations_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotationsConnection!
  business_name: String!
  contract_date: date

  # Displayed customer_id (on the website). Can be set by user
  customer_id: String!
  customer_type: Int!
  customers_states: uuid

  # An array relationship
  customers_users(
    # distinct select on columns
    distinct_on: [cpf_customers_users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_customers_users_order_by!]

    # filter the rows returned
    where: cpf_customers_users_bool_exp
  ): [cpf_customers_users!]!

  # An aggregated array relationship
  customers_users_aggregate(
    # distinct select on columns
    distinct_on: [cpf_customers_users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_customers_users_order_by!]

    # filter the rows returned
    where: cpf_customers_users_bool_exp
  ): cpf_customers_users_aggregate!

  # An array relationship connection
  customers_users_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_customers_users_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_customers_users_order_by!]

    # filter the rows returned
    where: cpf_customers_users_bool_exp
  ): cpf_customers_usersConnection!
  fein: String!
  id: ID!
  main_phone: String
  package_email: String

  # An array relationship
  packages(
    # distinct select on columns
    distinct_on: [cpf_packages_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_packages_order_by!]

    # filter the rows returned
    where: cpf_packages_bool_exp
  ): [cpf_packages!]!

  # An aggregated array relationship
  packages_aggregate(
    # distinct select on columns
    distinct_on: [cpf_packages_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_packages_order_by!]

    # filter the rows returned
    where: cpf_packages_bool_exp
  ): cpf_packages_aggregate!

  # An array relationship connection
  packages_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_packages_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_packages_order_by!]

    # filter the rows returned
    where: cpf_packages_bool_exp
  ): cpf_packagesConnection!
  tenant_id: uuid!
  zipcode: String
}

# aggregated selection of "cpf.customers"
type cpf_customers_aggregate {
  aggregate: cpf_customers_aggregate_fields
  nodes: [cpf_customers!]!
}

# aggregate fields of "cpf.customers"
type cpf_customers_aggregate_fields {
  avg: cpf_customers_avg_fields
  count(columns: [cpf_customers_select_column!], distinct: Boolean): Int
  max: cpf_customers_max_fields
  min: cpf_customers_min_fields
  stddev: cpf_customers_stddev_fields
  stddev_pop: cpf_customers_stddev_pop_fields
  stddev_samp: cpf_customers_stddev_samp_fields
  sum: cpf_customers_sum_fields
  var_pop: cpf_customers_var_pop_fields
  var_samp: cpf_customers_var_samp_fields
  variance: cpf_customers_variance_fields
}

# order by aggregate values of table "cpf.customers"
input cpf_customers_aggregate_order_by {
  avg: cpf_customers_avg_order_by
  count: order_by
  max: cpf_customers_max_order_by
  min: cpf_customers_min_order_by
  stddev: cpf_customers_stddev_order_by
  stddev_pop: cpf_customers_stddev_pop_order_by
  stddev_samp: cpf_customers_stddev_samp_order_by
  sum: cpf_customers_sum_order_by
  var_pop: cpf_customers_var_pop_order_by
  var_samp: cpf_customers_var_samp_order_by
  variance: cpf_customers_variance_order_by
}

# input type for inserting array relation for remote table "cpf.customers"
input cpf_customers_arr_rel_insert_input {
  data: [cpf_customers_insert_input!]!
  on_conflict: cpf_customers_on_conflict
}

# aggregate avg on columns
type cpf_customers_avg_fields {
  customer_type: Float
}

# order by avg() on columns of table "cpf.customers"
input cpf_customers_avg_order_by {
  customer_type: order_by
}

# Boolean expression to filter rows from the table "cpf.customers". All fields are combined with a logical 'AND'.
input cpf_customers_bool_exp {
  _and: [cpf_customers_bool_exp]
  _not: cpf_customers_bool_exp
  _or: [cpf_customers_bool_exp]
  address: String_comparison_exp
  annotations: cpf_annotations_bool_exp
  business_name: String_comparison_exp
  contract_date: date_comparison_exp
  customer_id: String_comparison_exp
  customer_type: Int_comparison_exp
  customers_states: uuid_comparison_exp
  customers_users: cpf_customers_users_bool_exp
  fein: String_comparison_exp
  id: uuid_comparison_exp
  main_phone: String_comparison_exp
  package_email: String_comparison_exp
  packages: cpf_packages_bool_exp
  tenant_id: uuid_comparison_exp
  zipcode: String_comparison_exp
}

# unique or primary key constraints on table "cpf.customers"
enum cpf_customers_constraint {
  # unique or primary key constraint
  customers_pkey

  # unique or primary key constraint
  customers_tenant_id_customer_id_key

  # unique or primary key constraint
  customers_tenant_id_fein_key
}

# input type for incrementing integer column in table "cpf.customers"
input cpf_customers_inc_input {
  customer_type: Int
}

# input type for inserting data into table "cpf.customers"
input cpf_customers_insert_input {
  address: String
  annotations: cpf_annotations_arr_rel_insert_input
  business_name: String
  contract_date: date
  customer_id: String
  customer_type: Int
  customers_states: uuid
  customers_users: cpf_customers_users_arr_rel_insert_input
  fein: String
  id: uuid
  main_phone: String
  package_email: String
  packages: cpf_packages_arr_rel_insert_input
  tenant_id: uuid
  zipcode: String
}

# aggregate max on columns
type cpf_customers_max_fields {
  address: String
  business_name: String
  contract_date: date
  customer_id: String
  customer_type: Int
  customers_states: uuid
  fein: String
  id: uuid
  main_phone: String
  package_email: String
  tenant_id: uuid
  zipcode: String
}

# order by max() on columns of table "cpf.customers"
input cpf_customers_max_order_by {
  address: order_by
  business_name: order_by
  contract_date: order_by
  customer_id: order_by
  customer_type: order_by
  customers_states: order_by
  fein: order_by
  id: order_by
  main_phone: order_by
  package_email: order_by
  tenant_id: order_by
  zipcode: order_by
}

# aggregate min on columns
type cpf_customers_min_fields {
  address: String
  business_name: String
  contract_date: date
  customer_id: String
  customer_type: Int
  customers_states: uuid
  fein: String
  id: uuid
  main_phone: String
  package_email: String
  tenant_id: uuid
  zipcode: String
}

# order by min() on columns of table "cpf.customers"
input cpf_customers_min_order_by {
  address: order_by
  business_name: order_by
  contract_date: order_by
  customer_id: order_by
  customer_type: order_by
  customers_states: order_by
  fein: order_by
  id: order_by
  main_phone: order_by
  package_email: order_by
  tenant_id: order_by
  zipcode: order_by
}

# response of any mutation on the table "cpf.customers"
type cpf_customers_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_customers!]!
}

# input type for inserting object relation for remote table "cpf.customers"
input cpf_customers_obj_rel_insert_input {
  data: cpf_customers_insert_input!
  on_conflict: cpf_customers_on_conflict
}

# on conflict condition type for table "cpf.customers"
input cpf_customers_on_conflict {
  constraint: cpf_customers_constraint!
  update_columns: [cpf_customers_update_column!]!
  where: cpf_customers_bool_exp
}

# ordering options when selecting data from "cpf.customers"
input cpf_customers_order_by {
  address: order_by
  annotations_aggregate: cpf_annotations_aggregate_order_by
  business_name: order_by
  contract_date: order_by
  customer_id: order_by
  customer_type: order_by
  customers_states: order_by
  customers_users_aggregate: cpf_customers_users_aggregate_order_by
  fein: order_by
  id: order_by
  main_phone: order_by
  package_email: order_by
  packages_aggregate: cpf_packages_aggregate_order_by
  tenant_id: order_by
  zipcode: order_by
}

# primary key columns input for table: "cpf.customers"
input cpf_customers_pk_columns_input {
  id: uuid!
}

# select columns of table "cpf.customers"
enum cpf_customers_select_column {
  # column name
  address

  # column name
  business_name

  # column name
  contract_date

  # column name
  customer_id

  # column name
  customer_type

  # column name
  customers_states

  # column name
  fein

  # column name
  id

  # column name
  main_phone

  # column name
  package_email

  # column name
  tenant_id

  # column name
  zipcode
}

# input type for updating data in table "cpf.customers"
input cpf_customers_set_input {
  address: String
  business_name: String
  contract_date: date
  customer_id: String
  customer_type: Int
  customers_states: uuid
  fein: String
  id: uuid
  main_phone: String
  package_email: String
  tenant_id: uuid
  zipcode: String
}

# aggregate stddev on columns
type cpf_customers_stddev_fields {
  customer_type: Float
}

# order by stddev() on columns of table "cpf.customers"
input cpf_customers_stddev_order_by {
  customer_type: order_by
}

# aggregate stddev_pop on columns
type cpf_customers_stddev_pop_fields {
  customer_type: Float
}

# order by stddev_pop() on columns of table "cpf.customers"
input cpf_customers_stddev_pop_order_by {
  customer_type: order_by
}

# aggregate stddev_samp on columns
type cpf_customers_stddev_samp_fields {
  customer_type: Float
}

# order by stddev_samp() on columns of table "cpf.customers"
input cpf_customers_stddev_samp_order_by {
  customer_type: order_by
}

# aggregate sum on columns
type cpf_customers_sum_fields {
  customer_type: Int
}

# order by sum() on columns of table "cpf.customers"
input cpf_customers_sum_order_by {
  customer_type: order_by
}

# update columns of table "cpf.customers"
enum cpf_customers_update_column {
  # column name
  address

  # column name
  business_name

  # column name
  contract_date

  # column name
  customer_id

  # column name
  customer_type

  # column name
  customers_states

  # column name
  fein

  # column name
  id

  # column name
  main_phone

  # column name
  package_email

  # column name
  tenant_id

  # column name
  zipcode
}

# columns and relationships of "cpf.customers_users"
type cpf_customers_users implements Node {
  # An object relationship
  customer: cpf_customers!
  customer_id: uuid!
  id: ID!

  # An object relationship
  user: cpf_users!
  user_id: uuid!
}

# aggregated selection of "cpf.customers_users"
type cpf_customers_users_aggregate {
  aggregate: cpf_customers_users_aggregate_fields
  nodes: [cpf_customers_users!]!
}

# aggregate fields of "cpf.customers_users"
type cpf_customers_users_aggregate_fields {
  count(columns: [cpf_customers_users_select_column!], distinct: Boolean): Int
  max: cpf_customers_users_max_fields
  min: cpf_customers_users_min_fields
}

# order by aggregate values of table "cpf.customers_users"
input cpf_customers_users_aggregate_order_by {
  count: order_by
  max: cpf_customers_users_max_order_by
  min: cpf_customers_users_min_order_by
}

# input type for inserting array relation for remote table "cpf.customers_users"
input cpf_customers_users_arr_rel_insert_input {
  data: [cpf_customers_users_insert_input!]!
  on_conflict: cpf_customers_users_on_conflict
}

# Boolean expression to filter rows from the table "cpf.customers_users". All fields are combined with a logical 'AND'.
input cpf_customers_users_bool_exp {
  _and: [cpf_customers_users_bool_exp]
  _not: cpf_customers_users_bool_exp
  _or: [cpf_customers_users_bool_exp]
  customer: cpf_customers_bool_exp
  customer_id: uuid_comparison_exp
  id: uuid_comparison_exp
  user: cpf_users_bool_exp
  user_id: uuid_comparison_exp
}

# unique or primary key constraints on table "cpf.customers_users"
enum cpf_customers_users_constraint {
  # unique or primary key constraint
  customers_users_pkey
}

# input type for inserting data into table "cpf.customers_users"
input cpf_customers_users_insert_input {
  customer: cpf_customers_obj_rel_insert_input
  customer_id: uuid
  id: uuid
  user: cpf_users_obj_rel_insert_input
  user_id: uuid
}

# aggregate max on columns
type cpf_customers_users_max_fields {
  customer_id: uuid
  id: uuid
  user_id: uuid
}

# order by max() on columns of table "cpf.customers_users"
input cpf_customers_users_max_order_by {
  customer_id: order_by
  id: order_by
  user_id: order_by
}

# aggregate min on columns
type cpf_customers_users_min_fields {
  customer_id: uuid
  id: uuid
  user_id: uuid
}

# order by min() on columns of table "cpf.customers_users"
input cpf_customers_users_min_order_by {
  customer_id: order_by
  id: order_by
  user_id: order_by
}

# response of any mutation on the table "cpf.customers_users"
type cpf_customers_users_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_customers_users!]!
}

# input type for inserting object relation for remote table "cpf.customers_users"
input cpf_customers_users_obj_rel_insert_input {
  data: cpf_customers_users_insert_input!
  on_conflict: cpf_customers_users_on_conflict
}

# on conflict condition type for table "cpf.customers_users"
input cpf_customers_users_on_conflict {
  constraint: cpf_customers_users_constraint!
  update_columns: [cpf_customers_users_update_column!]!
  where: cpf_customers_users_bool_exp
}

# ordering options when selecting data from "cpf.customers_users"
input cpf_customers_users_order_by {
  customer: cpf_customers_order_by
  customer_id: order_by
  id: order_by
  user: cpf_users_order_by
  user_id: order_by
}

# primary key columns input for table: "cpf.customers_users"
input cpf_customers_users_pk_columns_input {
  id: uuid!
}

# select columns of table "cpf.customers_users"
enum cpf_customers_users_select_column {
  # column name
  customer_id

  # column name
  id

  # column name
  user_id
}

# input type for updating data in table "cpf.customers_users"
input cpf_customers_users_set_input {
  customer_id: uuid
  id: uuid
  user_id: uuid
}

# update columns of table "cpf.customers_users"
enum cpf_customers_users_update_column {
  # column name
  customer_id

  # column name
  id

  # column name
  user_id
}

# A Relay Connection object on "cpf.customers_users"
type cpf_customers_usersConnection {
  edges: [cpf_customers_usersEdge!]!
  pageInfo: PageInfo!
}

type cpf_customers_usersEdge {
  cursor: String!
  node: cpf_customers_users!
}

# aggregate var_pop on columns
type cpf_customers_var_pop_fields {
  customer_type: Float
}

# order by var_pop() on columns of table "cpf.customers"
input cpf_customers_var_pop_order_by {
  customer_type: order_by
}

# aggregate var_samp on columns
type cpf_customers_var_samp_fields {
  customer_type: Float
}

# order by var_samp() on columns of table "cpf.customers"
input cpf_customers_var_samp_order_by {
  customer_type: order_by
}

# aggregate variance on columns
type cpf_customers_variance_fields {
  customer_type: Float
}

# order by variance() on columns of table "cpf.customers"
input cpf_customers_variance_order_by {
  customer_type: order_by
}

# A Relay Connection object on "cpf.customers"
type cpf_customersConnection {
  edges: [cpf_customersEdge!]!
  pageInfo: PageInfo!
}

type cpf_customersEdge {
  cursor: String!
  node: cpf_customers!
}

# columns and relationships of "cpf.email_queue"
type cpf_email_queue implements Node {
  bcc: String
  body: String!
  cc: String
  created_at: timestamptz

  # An object relationship
  email_status: cpf_email_status!
  from: String!
  id: ID!
  package_url: String!
  retry_count: Int!
  sent_at: timestamptz
  status: cpf_email_status_enum!
  subject: String!
  to: String!
  updated_at: timestamptz
}

# aggregated selection of "cpf.email_queue"
type cpf_email_queue_aggregate {
  aggregate: cpf_email_queue_aggregate_fields
  nodes: [cpf_email_queue!]!
}

# aggregate fields of "cpf.email_queue"
type cpf_email_queue_aggregate_fields {
  avg: cpf_email_queue_avg_fields
  count(columns: [cpf_email_queue_select_column!], distinct: Boolean): Int
  max: cpf_email_queue_max_fields
  min: cpf_email_queue_min_fields
  stddev: cpf_email_queue_stddev_fields
  stddev_pop: cpf_email_queue_stddev_pop_fields
  stddev_samp: cpf_email_queue_stddev_samp_fields
  sum: cpf_email_queue_sum_fields
  var_pop: cpf_email_queue_var_pop_fields
  var_samp: cpf_email_queue_var_samp_fields
  variance: cpf_email_queue_variance_fields
}

# order by aggregate values of table "cpf.email_queue"
input cpf_email_queue_aggregate_order_by {
  avg: cpf_email_queue_avg_order_by
  count: order_by
  max: cpf_email_queue_max_order_by
  min: cpf_email_queue_min_order_by
  stddev: cpf_email_queue_stddev_order_by
  stddev_pop: cpf_email_queue_stddev_pop_order_by
  stddev_samp: cpf_email_queue_stddev_samp_order_by
  sum: cpf_email_queue_sum_order_by
  var_pop: cpf_email_queue_var_pop_order_by
  var_samp: cpf_email_queue_var_samp_order_by
  variance: cpf_email_queue_variance_order_by
}

# input type for inserting array relation for remote table "cpf.email_queue"
input cpf_email_queue_arr_rel_insert_input {
  data: [cpf_email_queue_insert_input!]!
  on_conflict: cpf_email_queue_on_conflict
}

# aggregate avg on columns
type cpf_email_queue_avg_fields {
  retry_count: Float
}

# order by avg() on columns of table "cpf.email_queue"
input cpf_email_queue_avg_order_by {
  retry_count: order_by
}

# Boolean expression to filter rows from the table "cpf.email_queue". All fields are combined with a logical 'AND'.
input cpf_email_queue_bool_exp {
  _and: [cpf_email_queue_bool_exp]
  _not: cpf_email_queue_bool_exp
  _or: [cpf_email_queue_bool_exp]
  bcc: String_comparison_exp
  body: String_comparison_exp
  cc: String_comparison_exp
  created_at: timestamptz_comparison_exp
  email_status: cpf_email_status_bool_exp
  from: String_comparison_exp
  id: uuid_comparison_exp
  package_url: String_comparison_exp
  retry_count: Int_comparison_exp
  sent_at: timestamptz_comparison_exp
  status: cpf_email_status_enum_comparison_exp
  subject: String_comparison_exp
  to: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "cpf.email_queue"
enum cpf_email_queue_constraint {
  # unique or primary key constraint
  email_queue_pkey
}

# input type for incrementing integer column in table "cpf.email_queue"
input cpf_email_queue_inc_input {
  retry_count: Int
}

# input type for inserting data into table "cpf.email_queue"
input cpf_email_queue_insert_input {
  bcc: String
  body: String
  cc: String
  created_at: timestamptz
  email_status: cpf_email_status_obj_rel_insert_input
  from: String
  id: uuid
  package_url: String
  retry_count: Int
  sent_at: timestamptz
  status: cpf_email_status_enum
  subject: String
  to: String
  updated_at: timestamptz
}

# aggregate max on columns
type cpf_email_queue_max_fields {
  bcc: String
  body: String
  cc: String
  created_at: timestamptz
  from: String
  id: uuid
  package_url: String
  retry_count: Int
  sent_at: timestamptz
  subject: String
  to: String
  updated_at: timestamptz
}

# order by max() on columns of table "cpf.email_queue"
input cpf_email_queue_max_order_by {
  bcc: order_by
  body: order_by
  cc: order_by
  created_at: order_by
  from: order_by
  id: order_by
  package_url: order_by
  retry_count: order_by
  sent_at: order_by
  subject: order_by
  to: order_by
  updated_at: order_by
}

# aggregate min on columns
type cpf_email_queue_min_fields {
  bcc: String
  body: String
  cc: String
  created_at: timestamptz
  from: String
  id: uuid
  package_url: String
  retry_count: Int
  sent_at: timestamptz
  subject: String
  to: String
  updated_at: timestamptz
}

# order by min() on columns of table "cpf.email_queue"
input cpf_email_queue_min_order_by {
  bcc: order_by
  body: order_by
  cc: order_by
  created_at: order_by
  from: order_by
  id: order_by
  package_url: order_by
  retry_count: order_by
  sent_at: order_by
  subject: order_by
  to: order_by
  updated_at: order_by
}

# response of any mutation on the table "cpf.email_queue"
type cpf_email_queue_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_email_queue!]!
}

# input type for inserting object relation for remote table "cpf.email_queue"
input cpf_email_queue_obj_rel_insert_input {
  data: cpf_email_queue_insert_input!
  on_conflict: cpf_email_queue_on_conflict
}

# on conflict condition type for table "cpf.email_queue"
input cpf_email_queue_on_conflict {
  constraint: cpf_email_queue_constraint!
  update_columns: [cpf_email_queue_update_column!]!
  where: cpf_email_queue_bool_exp
}

# ordering options when selecting data from "cpf.email_queue"
input cpf_email_queue_order_by {
  bcc: order_by
  body: order_by
  cc: order_by
  created_at: order_by
  email_status: cpf_email_status_order_by
  from: order_by
  id: order_by
  package_url: order_by
  retry_count: order_by
  sent_at: order_by
  status: order_by
  subject: order_by
  to: order_by
  updated_at: order_by
}

# primary key columns input for table: "cpf.email_queue"
input cpf_email_queue_pk_columns_input {
  id: uuid!
}

# select columns of table "cpf.email_queue"
enum cpf_email_queue_select_column {
  # column name
  bcc

  # column name
  body

  # column name
  cc

  # column name
  created_at

  # column name
  from

  # column name
  id

  # column name
  package_url

  # column name
  retry_count

  # column name
  sent_at

  # column name
  status

  # column name
  subject

  # column name
  to

  # column name
  updated_at
}

# input type for updating data in table "cpf.email_queue"
input cpf_email_queue_set_input {
  bcc: String
  body: String
  cc: String
  created_at: timestamptz
  from: String
  id: uuid
  package_url: String
  retry_count: Int
  sent_at: timestamptz
  status: cpf_email_status_enum
  subject: String
  to: String
  updated_at: timestamptz
}

# aggregate stddev on columns
type cpf_email_queue_stddev_fields {
  retry_count: Float
}

# order by stddev() on columns of table "cpf.email_queue"
input cpf_email_queue_stddev_order_by {
  retry_count: order_by
}

# aggregate stddev_pop on columns
type cpf_email_queue_stddev_pop_fields {
  retry_count: Float
}

# order by stddev_pop() on columns of table "cpf.email_queue"
input cpf_email_queue_stddev_pop_order_by {
  retry_count: order_by
}

# aggregate stddev_samp on columns
type cpf_email_queue_stddev_samp_fields {
  retry_count: Float
}

# order by stddev_samp() on columns of table "cpf.email_queue"
input cpf_email_queue_stddev_samp_order_by {
  retry_count: order_by
}

# aggregate sum on columns
type cpf_email_queue_sum_fields {
  retry_count: Int
}

# order by sum() on columns of table "cpf.email_queue"
input cpf_email_queue_sum_order_by {
  retry_count: order_by
}

# update columns of table "cpf.email_queue"
enum cpf_email_queue_update_column {
  # column name
  bcc

  # column name
  body

  # column name
  cc

  # column name
  created_at

  # column name
  from

  # column name
  id

  # column name
  package_url

  # column name
  retry_count

  # column name
  sent_at

  # column name
  status

  # column name
  subject

  # column name
  to

  # column name
  updated_at
}

# aggregate var_pop on columns
type cpf_email_queue_var_pop_fields {
  retry_count: Float
}

# order by var_pop() on columns of table "cpf.email_queue"
input cpf_email_queue_var_pop_order_by {
  retry_count: order_by
}

# aggregate var_samp on columns
type cpf_email_queue_var_samp_fields {
  retry_count: Float
}

# order by var_samp() on columns of table "cpf.email_queue"
input cpf_email_queue_var_samp_order_by {
  retry_count: order_by
}

# aggregate variance on columns
type cpf_email_queue_variance_fields {
  retry_count: Float
}

# order by variance() on columns of table "cpf.email_queue"
input cpf_email_queue_variance_order_by {
  retry_count: order_by
}

# A Relay Connection object on "cpf.email_queue"
type cpf_email_queueConnection {
  edges: [cpf_email_queueEdge!]!
  pageInfo: PageInfo!
}

type cpf_email_queueEdge {
  cursor: String!
  node: cpf_email_queue!
}

# columns and relationships of "cpf.email_status"
type cpf_email_status implements Node {
  comment: String!

  # An array relationship
  email_queues(
    # distinct select on columns
    distinct_on: [cpf_email_queue_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_email_queue_order_by!]

    # filter the rows returned
    where: cpf_email_queue_bool_exp
  ): [cpf_email_queue!]!

  # An aggregated array relationship
  email_queues_aggregate(
    # distinct select on columns
    distinct_on: [cpf_email_queue_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_email_queue_order_by!]

    # filter the rows returned
    where: cpf_email_queue_bool_exp
  ): cpf_email_queue_aggregate!

  # An array relationship connection
  email_queues_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_email_queue_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_email_queue_order_by!]

    # filter the rows returned
    where: cpf_email_queue_bool_exp
  ): cpf_email_queueConnection!
  id: ID!
}

# aggregated selection of "cpf.email_status"
type cpf_email_status_aggregate {
  aggregate: cpf_email_status_aggregate_fields
  nodes: [cpf_email_status!]!
}

# aggregate fields of "cpf.email_status"
type cpf_email_status_aggregate_fields {
  count(columns: [cpf_email_status_select_column!], distinct: Boolean): Int
  max: cpf_email_status_max_fields
  min: cpf_email_status_min_fields
}

# order by aggregate values of table "cpf.email_status"
input cpf_email_status_aggregate_order_by {
  count: order_by
  max: cpf_email_status_max_order_by
  min: cpf_email_status_min_order_by
}

# input type for inserting array relation for remote table "cpf.email_status"
input cpf_email_status_arr_rel_insert_input {
  data: [cpf_email_status_insert_input!]!
  on_conflict: cpf_email_status_on_conflict
}

# Boolean expression to filter rows from the table "cpf.email_status". All fields are combined with a logical 'AND'.
input cpf_email_status_bool_exp {
  _and: [cpf_email_status_bool_exp]
  _not: cpf_email_status_bool_exp
  _or: [cpf_email_status_bool_exp]
  comment: String_comparison_exp
  email_queues: cpf_email_queue_bool_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "cpf.email_status"
enum cpf_email_status_constraint {
  # unique or primary key constraint
  email_status_pkey
}

enum cpf_email_status_enum {
  # Indicates that an email failed to send, and is now subject to retry handling.
  failed

  # Indicates that an email is currently being edited by another process and should not be sent
  in_progress

  # Indicates that an email is ready to be processed.
  queued

  # Email was sent, and is now only needed for historical purposes.
  sent
}

# expression to compare columns of type cpf_email_status_enum. All fields are combined with logical 'AND'.
input cpf_email_status_enum_comparison_exp {
  _eq: cpf_email_status_enum
  _in: [cpf_email_status_enum!]
  _is_null: Boolean
  _neq: cpf_email_status_enum
  _nin: [cpf_email_status_enum!]
}

# input type for inserting data into table "cpf.email_status"
input cpf_email_status_insert_input {
  comment: String
  email_queues: cpf_email_queue_arr_rel_insert_input
  id: String
}

# aggregate max on columns
type cpf_email_status_max_fields {
  comment: String
  id: String
}

# order by max() on columns of table "cpf.email_status"
input cpf_email_status_max_order_by {
  comment: order_by
  id: order_by
}

# aggregate min on columns
type cpf_email_status_min_fields {
  comment: String
  id: String
}

# order by min() on columns of table "cpf.email_status"
input cpf_email_status_min_order_by {
  comment: order_by
  id: order_by
}

# response of any mutation on the table "cpf.email_status"
type cpf_email_status_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_email_status!]!
}

# input type for inserting object relation for remote table "cpf.email_status"
input cpf_email_status_obj_rel_insert_input {
  data: cpf_email_status_insert_input!
  on_conflict: cpf_email_status_on_conflict
}

# on conflict condition type for table "cpf.email_status"
input cpf_email_status_on_conflict {
  constraint: cpf_email_status_constraint!
  update_columns: [cpf_email_status_update_column!]!
  where: cpf_email_status_bool_exp
}

# ordering options when selecting data from "cpf.email_status"
input cpf_email_status_order_by {
  comment: order_by
  email_queues_aggregate: cpf_email_queue_aggregate_order_by
  id: order_by
}

# primary key columns input for table: "cpf.email_status"
input cpf_email_status_pk_columns_input {
  id: String!
}

# select columns of table "cpf.email_status"
enum cpf_email_status_select_column {
  # column name
  comment

  # column name
  id
}

# input type for updating data in table "cpf.email_status"
input cpf_email_status_set_input {
  comment: String
  id: String
}

# update columns of table "cpf.email_status"
enum cpf_email_status_update_column {
  # column name
  comment

  # column name
  id
}

# A Relay Connection object on "cpf.email_status"
type cpf_email_statusConnection {
  edges: [cpf_email_statusEdge!]!
  pageInfo: PageInfo!
}

type cpf_email_statusEdge {
  cursor: String!
  node: cpf_email_status!
}

# columns and relationships of "cpf.email_templates"
type cpf_email_templates implements Node {
  body: String!
  created_at: timestamptz!
  id: ID!

  # An object relationship
  tenant: cpf_tenants!
  tenant_id: uuid!
  updated_at: timestamptz!
}

# aggregated selection of "cpf.email_templates"
type cpf_email_templates_aggregate {
  aggregate: cpf_email_templates_aggregate_fields
  nodes: [cpf_email_templates!]!
}

# aggregate fields of "cpf.email_templates"
type cpf_email_templates_aggregate_fields {
  count(columns: [cpf_email_templates_select_column!], distinct: Boolean): Int
  max: cpf_email_templates_max_fields
  min: cpf_email_templates_min_fields
}

# order by aggregate values of table "cpf.email_templates"
input cpf_email_templates_aggregate_order_by {
  count: order_by
  max: cpf_email_templates_max_order_by
  min: cpf_email_templates_min_order_by
}

# input type for inserting array relation for remote table "cpf.email_templates"
input cpf_email_templates_arr_rel_insert_input {
  data: [cpf_email_templates_insert_input!]!
  on_conflict: cpf_email_templates_on_conflict
}

# Boolean expression to filter rows from the table "cpf.email_templates". All fields are combined with a logical 'AND'.
input cpf_email_templates_bool_exp {
  _and: [cpf_email_templates_bool_exp]
  _not: cpf_email_templates_bool_exp
  _or: [cpf_email_templates_bool_exp]
  body: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  tenant: cpf_tenants_bool_exp
  tenant_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "cpf.email_templates"
enum cpf_email_templates_constraint {
  # unique or primary key constraint
  email_templates_pkey
}

# input type for inserting data into table "cpf.email_templates"
input cpf_email_templates_insert_input {
  body: String
  created_at: timestamptz
  id: uuid
  tenant: cpf_tenants_obj_rel_insert_input
  tenant_id: uuid
  updated_at: timestamptz
}

# aggregate max on columns
type cpf_email_templates_max_fields {
  body: String
  created_at: timestamptz
  id: uuid
  tenant_id: uuid
  updated_at: timestamptz
}

# order by max() on columns of table "cpf.email_templates"
input cpf_email_templates_max_order_by {
  body: order_by
  created_at: order_by
  id: order_by
  tenant_id: order_by
  updated_at: order_by
}

# aggregate min on columns
type cpf_email_templates_min_fields {
  body: String
  created_at: timestamptz
  id: uuid
  tenant_id: uuid
  updated_at: timestamptz
}

# order by min() on columns of table "cpf.email_templates"
input cpf_email_templates_min_order_by {
  body: order_by
  created_at: order_by
  id: order_by
  tenant_id: order_by
  updated_at: order_by
}

# response of any mutation on the table "cpf.email_templates"
type cpf_email_templates_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_email_templates!]!
}

# input type for inserting object relation for remote table "cpf.email_templates"
input cpf_email_templates_obj_rel_insert_input {
  data: cpf_email_templates_insert_input!
  on_conflict: cpf_email_templates_on_conflict
}

# on conflict condition type for table "cpf.email_templates"
input cpf_email_templates_on_conflict {
  constraint: cpf_email_templates_constraint!
  update_columns: [cpf_email_templates_update_column!]!
  where: cpf_email_templates_bool_exp
}

# ordering options when selecting data from "cpf.email_templates"
input cpf_email_templates_order_by {
  body: order_by
  created_at: order_by
  id: order_by
  tenant: cpf_tenants_order_by
  tenant_id: order_by
  updated_at: order_by
}

# primary key columns input for table: "cpf.email_templates"
input cpf_email_templates_pk_columns_input {
  id: uuid!
}

# select columns of table "cpf.email_templates"
enum cpf_email_templates_select_column {
  # column name
  body

  # column name
  created_at

  # column name
  id

  # column name
  tenant_id

  # column name
  updated_at
}

# input type for updating data in table "cpf.email_templates"
input cpf_email_templates_set_input {
  body: String
  created_at: timestamptz
  id: uuid
  tenant_id: uuid
  updated_at: timestamptz
}

# update columns of table "cpf.email_templates"
enum cpf_email_templates_update_column {
  # column name
  body

  # column name
  created_at

  # column name
  id

  # column name
  tenant_id

  # column name
  updated_at
}

# A Relay Connection object on "cpf.email_templates"
type cpf_email_templatesConnection {
  edges: [cpf_email_templatesEdge!]!
  pageInfo: PageInfo!
}

type cpf_email_templatesEdge {
  cursor: String!
  node: cpf_email_templates!
}

# columns and relationships of "cpf.level"
type cpf_level implements Node {
  comment: String!

  # An array relationship
  custom_forms_libraries(
    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_bool_exp
  ): [cpf_custom_forms_library!]!

  # An aggregated array relationship
  custom_forms_libraries_aggregate(
    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_bool_exp
  ): cpf_custom_forms_library_aggregate!

  # An array relationship connection
  custom_forms_libraries_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_bool_exp
  ): cpf_custom_forms_libraryConnection!
  id: ID!
}

# aggregated selection of "cpf.level"
type cpf_level_aggregate {
  aggregate: cpf_level_aggregate_fields
  nodes: [cpf_level!]!
}

# aggregate fields of "cpf.level"
type cpf_level_aggregate_fields {
  count(columns: [cpf_level_select_column!], distinct: Boolean): Int
  max: cpf_level_max_fields
  min: cpf_level_min_fields
}

# order by aggregate values of table "cpf.level"
input cpf_level_aggregate_order_by {
  count: order_by
  max: cpf_level_max_order_by
  min: cpf_level_min_order_by
}

# input type for inserting array relation for remote table "cpf.level"
input cpf_level_arr_rel_insert_input {
  data: [cpf_level_insert_input!]!
  on_conflict: cpf_level_on_conflict
}

# Boolean expression to filter rows from the table "cpf.level". All fields are combined with a logical 'AND'.
input cpf_level_bool_exp {
  _and: [cpf_level_bool_exp]
  _not: cpf_level_bool_exp
  _or: [cpf_level_bool_exp]
  comment: String_comparison_exp
  custom_forms_libraries: cpf_custom_forms_library_bool_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "cpf.level"
enum cpf_level_constraint {
  # unique or primary key constraint
  level_pkey
}

enum cpf_level_enum {
  # For taxes applied at the city level.
  city

  # For taxes applied at the county level.
  county

  # For taxes applied at the federal level.
  federal

  # For taxes applied at the state/province level.
  state
}

# expression to compare columns of type cpf_level_enum. All fields are combined with logical 'AND'.
input cpf_level_enum_comparison_exp {
  _eq: cpf_level_enum
  _in: [cpf_level_enum!]
  _is_null: Boolean
  _neq: cpf_level_enum
  _nin: [cpf_level_enum!]
}

# input type for inserting data into table "cpf.level"
input cpf_level_insert_input {
  comment: String
  custom_forms_libraries: cpf_custom_forms_library_arr_rel_insert_input
  id: String
}

# aggregate max on columns
type cpf_level_max_fields {
  comment: String
  id: String
}

# order by max() on columns of table "cpf.level"
input cpf_level_max_order_by {
  comment: order_by
  id: order_by
}

# aggregate min on columns
type cpf_level_min_fields {
  comment: String
  id: String
}

# order by min() on columns of table "cpf.level"
input cpf_level_min_order_by {
  comment: order_by
  id: order_by
}

# response of any mutation on the table "cpf.level"
type cpf_level_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_level!]!
}

# input type for inserting object relation for remote table "cpf.level"
input cpf_level_obj_rel_insert_input {
  data: cpf_level_insert_input!
  on_conflict: cpf_level_on_conflict
}

# on conflict condition type for table "cpf.level"
input cpf_level_on_conflict {
  constraint: cpf_level_constraint!
  update_columns: [cpf_level_update_column!]!
  where: cpf_level_bool_exp
}

# ordering options when selecting data from "cpf.level"
input cpf_level_order_by {
  comment: order_by
  custom_forms_libraries_aggregate: cpf_custom_forms_library_aggregate_order_by
  id: order_by
}

# primary key columns input for table: "cpf.level"
input cpf_level_pk_columns_input {
  id: String!
}

# select columns of table "cpf.level"
enum cpf_level_select_column {
  # column name
  comment

  # column name
  id
}

# input type for updating data in table "cpf.level"
input cpf_level_set_input {
  comment: String
  id: String
}

# update columns of table "cpf.level"
enum cpf_level_update_column {
  # column name
  comment

  # column name
  id
}

# A Relay Connection object on "cpf.level"
type cpf_levelConnection {
  edges: [cpf_levelEdge!]!
  pageInfo: PageInfo!
}

type cpf_levelEdge {
  cursor: String!
  node: cpf_level!
}

# columns and relationships of "cpf.package_request_status"
type cpf_package_request_status implements Node {
  comment: String!
  id: ID!

  # An array relationship
  package_requests(
    # distinct select on columns
    distinct_on: [cpf_package_requests_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_package_requests_order_by!]

    # filter the rows returned
    where: cpf_package_requests_bool_exp
  ): [cpf_package_requests!]!

  # An aggregated array relationship
  package_requests_aggregate(
    # distinct select on columns
    distinct_on: [cpf_package_requests_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_package_requests_order_by!]

    # filter the rows returned
    where: cpf_package_requests_bool_exp
  ): cpf_package_requests_aggregate!

  # An array relationship connection
  package_requests_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_package_requests_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_package_requests_order_by!]

    # filter the rows returned
    where: cpf_package_requests_bool_exp
  ): cpf_package_requestsConnection!
}

# aggregated selection of "cpf.package_request_status"
type cpf_package_request_status_aggregate {
  aggregate: cpf_package_request_status_aggregate_fields
  nodes: [cpf_package_request_status!]!
}

# aggregate fields of "cpf.package_request_status"
type cpf_package_request_status_aggregate_fields {
  count(columns: [cpf_package_request_status_select_column!], distinct: Boolean): Int
  max: cpf_package_request_status_max_fields
  min: cpf_package_request_status_min_fields
}

# order by aggregate values of table "cpf.package_request_status"
input cpf_package_request_status_aggregate_order_by {
  count: order_by
  max: cpf_package_request_status_max_order_by
  min: cpf_package_request_status_min_order_by
}

# input type for inserting array relation for remote table "cpf.package_request_status"
input cpf_package_request_status_arr_rel_insert_input {
  data: [cpf_package_request_status_insert_input!]!
  on_conflict: cpf_package_request_status_on_conflict
}

# Boolean expression to filter rows from the table "cpf.package_request_status". All fields are combined with a logical 'AND'.
input cpf_package_request_status_bool_exp {
  _and: [cpf_package_request_status_bool_exp]
  _not: cpf_package_request_status_bool_exp
  _or: [cpf_package_request_status_bool_exp]
  comment: String_comparison_exp
  id: String_comparison_exp
  package_requests: cpf_package_requests_bool_exp
}

# unique or primary key constraints on table "cpf.package_request_status"
enum cpf_package_request_status_constraint {
  # unique or primary key constraint
  status_pkey
}

enum cpf_package_request_status_enum {
  # Indicates that a file has been fully approved and the associated exemption should be considered active.
  approved

  # Indicates that a record has been created but no actions have been run against it.
  created

  # Indicates that an email has been successfully sent regarding the latest changes to the record.
  email_sent

  # Indicates that an upload has been rejected, but no further action (i.e. an email) has been completed in the system.
  rejected

  # Indicates that a file has been reviewed and appears accurate, but needs to be
  # signed off on by an authorized user. Reviewed items are not considered valid
  # exemptions yet.
  reviewed

  # Indicates that a file has been uploaded regarding the record, but no further action has been taken.
  uploaded
}

# expression to compare columns of type cpf_package_request_status_enum. All fields are combined with logical 'AND'.
input cpf_package_request_status_enum_comparison_exp {
  _eq: cpf_package_request_status_enum
  _in: [cpf_package_request_status_enum!]
  _is_null: Boolean
  _neq: cpf_package_request_status_enum
  _nin: [cpf_package_request_status_enum!]
}

# input type for inserting data into table "cpf.package_request_status"
input cpf_package_request_status_insert_input {
  comment: String
  id: String
  package_requests: cpf_package_requests_arr_rel_insert_input
}

# aggregate max on columns
type cpf_package_request_status_max_fields {
  comment: String
  id: String
}

# order by max() on columns of table "cpf.package_request_status"
input cpf_package_request_status_max_order_by {
  comment: order_by
  id: order_by
}

# aggregate min on columns
type cpf_package_request_status_min_fields {
  comment: String
  id: String
}

# order by min() on columns of table "cpf.package_request_status"
input cpf_package_request_status_min_order_by {
  comment: order_by
  id: order_by
}

# response of any mutation on the table "cpf.package_request_status"
type cpf_package_request_status_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_package_request_status!]!
}

# input type for inserting object relation for remote table "cpf.package_request_status"
input cpf_package_request_status_obj_rel_insert_input {
  data: cpf_package_request_status_insert_input!
  on_conflict: cpf_package_request_status_on_conflict
}

# on conflict condition type for table "cpf.package_request_status"
input cpf_package_request_status_on_conflict {
  constraint: cpf_package_request_status_constraint!
  update_columns: [cpf_package_request_status_update_column!]!
  where: cpf_package_request_status_bool_exp
}

# ordering options when selecting data from "cpf.package_request_status"
input cpf_package_request_status_order_by {
  comment: order_by
  id: order_by
  package_requests_aggregate: cpf_package_requests_aggregate_order_by
}

# primary key columns input for table: "cpf.package_request_status"
input cpf_package_request_status_pk_columns_input {
  id: String!
}

# select columns of table "cpf.package_request_status"
enum cpf_package_request_status_select_column {
  # column name
  comment

  # column name
  id
}

# input type for updating data in table "cpf.package_request_status"
input cpf_package_request_status_set_input {
  comment: String
  id: String
}

# update columns of table "cpf.package_request_status"
enum cpf_package_request_status_update_column {
  # column name
  comment

  # column name
  id
}

# A Relay Connection object on "cpf.package_request_status"
type cpf_package_request_statusConnection {
  edges: [cpf_package_request_statusEdge!]!
  pageInfo: PageInfo!
}

type cpf_package_request_statusEdge {
  cursor: String!
  node: cpf_package_request_status!
}

# columns and relationships of "cpf.package_requests"
type cpf_package_requests implements Node {
  # An array relationship
  annotations(
    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): [cpf_annotations!]!

  # An aggregated array relationship
  annotations_aggregate(
    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotations_aggregate!

  # An array relationship connection
  annotations_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotationsConnection!
  created_at: timestamptz
  id: ID!
  level: String!

  # An object relationship
  package: cpf_packages!
  package_id: uuid!

  # An object relationship
  package_request_status: cpf_package_request_status!

  # An array relationship
  package_responses(
    # distinct select on columns
    distinct_on: [cpf_package_responses_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_package_responses_order_by!]

    # filter the rows returned
    where: cpf_package_responses_bool_exp
  ): [cpf_package_responses!]!

  # An aggregated array relationship
  package_responses_aggregate(
    # distinct select on columns
    distinct_on: [cpf_package_responses_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_package_responses_order_by!]

    # filter the rows returned
    where: cpf_package_responses_bool_exp
  ): cpf_package_responses_aggregate!

  # An array relationship connection
  package_responses_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_package_responses_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_package_responses_order_by!]

    # filter the rows returned
    where: cpf_package_responses_bool_exp
  ): cpf_package_responsesConnection!
  status: cpf_package_request_status_enum!
  updated_at: timestamptz
}

# aggregated selection of "cpf.package_requests"
type cpf_package_requests_aggregate {
  aggregate: cpf_package_requests_aggregate_fields
  nodes: [cpf_package_requests!]!
}

# aggregate fields of "cpf.package_requests"
type cpf_package_requests_aggregate_fields {
  count(columns: [cpf_package_requests_select_column!], distinct: Boolean): Int
  max: cpf_package_requests_max_fields
  min: cpf_package_requests_min_fields
}

# order by aggregate values of table "cpf.package_requests"
input cpf_package_requests_aggregate_order_by {
  count: order_by
  max: cpf_package_requests_max_order_by
  min: cpf_package_requests_min_order_by
}

# input type for inserting array relation for remote table "cpf.package_requests"
input cpf_package_requests_arr_rel_insert_input {
  data: [cpf_package_requests_insert_input!]!
  on_conflict: cpf_package_requests_on_conflict
}

# Boolean expression to filter rows from the table "cpf.package_requests". All fields are combined with a logical 'AND'.
input cpf_package_requests_bool_exp {
  _and: [cpf_package_requests_bool_exp]
  _not: cpf_package_requests_bool_exp
  _or: [cpf_package_requests_bool_exp]
  annotations: cpf_annotations_bool_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  level: String_comparison_exp
  package: cpf_packages_bool_exp
  package_id: uuid_comparison_exp
  package_request_status: cpf_package_request_status_bool_exp
  package_responses: cpf_package_responses_bool_exp
  status: cpf_package_request_status_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "cpf.package_requests"
enum cpf_package_requests_constraint {
  # unique or primary key constraint
  package_requests_pkey
}

# input type for inserting data into table "cpf.package_requests"
input cpf_package_requests_insert_input {
  annotations: cpf_annotations_arr_rel_insert_input
  created_at: timestamptz
  id: uuid
  level: String
  package: cpf_packages_obj_rel_insert_input
  package_id: uuid
  package_request_status: cpf_package_request_status_obj_rel_insert_input
  package_responses: cpf_package_responses_arr_rel_insert_input
  status: cpf_package_request_status_enum
  updated_at: timestamptz
}

# aggregate max on columns
type cpf_package_requests_max_fields {
  created_at: timestamptz
  id: uuid
  level: String
  package_id: uuid
  updated_at: timestamptz
}

# order by max() on columns of table "cpf.package_requests"
input cpf_package_requests_max_order_by {
  created_at: order_by
  id: order_by
  level: order_by
  package_id: order_by
  updated_at: order_by
}

# aggregate min on columns
type cpf_package_requests_min_fields {
  created_at: timestamptz
  id: uuid
  level: String
  package_id: uuid
  updated_at: timestamptz
}

# order by min() on columns of table "cpf.package_requests"
input cpf_package_requests_min_order_by {
  created_at: order_by
  id: order_by
  level: order_by
  package_id: order_by
  updated_at: order_by
}

# response of any mutation on the table "cpf.package_requests"
type cpf_package_requests_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_package_requests!]!
}

# input type for inserting object relation for remote table "cpf.package_requests"
input cpf_package_requests_obj_rel_insert_input {
  data: cpf_package_requests_insert_input!
  on_conflict: cpf_package_requests_on_conflict
}

# on conflict condition type for table "cpf.package_requests"
input cpf_package_requests_on_conflict {
  constraint: cpf_package_requests_constraint!
  update_columns: [cpf_package_requests_update_column!]!
  where: cpf_package_requests_bool_exp
}

# ordering options when selecting data from "cpf.package_requests"
input cpf_package_requests_order_by {
  annotations_aggregate: cpf_annotations_aggregate_order_by
  created_at: order_by
  id: order_by
  level: order_by
  package: cpf_packages_order_by
  package_id: order_by
  package_request_status: cpf_package_request_status_order_by
  package_responses_aggregate: cpf_package_responses_aggregate_order_by
  status: order_by
  updated_at: order_by
}

# primary key columns input for table: "cpf.package_requests"
input cpf_package_requests_pk_columns_input {
  id: uuid!
}

# select columns of table "cpf.package_requests"
enum cpf_package_requests_select_column {
  # column name
  created_at

  # column name
  id

  # column name
  level

  # column name
  package_id

  # column name
  status

  # column name
  updated_at
}

# input type for updating data in table "cpf.package_requests"
input cpf_package_requests_set_input {
  created_at: timestamptz
  id: uuid
  level: String
  package_id: uuid
  status: cpf_package_request_status_enum
  updated_at: timestamptz
}

# update columns of table "cpf.package_requests"
enum cpf_package_requests_update_column {
  # column name
  created_at

  # column name
  id

  # column name
  level

  # column name
  package_id

  # column name
  status

  # column name
  updated_at
}

# A Relay Connection object on "cpf.package_requests"
type cpf_package_requestsConnection {
  edges: [cpf_package_requestsEdge!]!
  pageInfo: PageInfo!
}

type cpf_package_requestsEdge {
  cursor: String!
  node: cpf_package_requests!
}

# columns and relationships of "cpf.package_responses"
type cpf_package_responses implements Node {
  # An array relationship
  annotations(
    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): [cpf_annotations!]!

  # An aggregated array relationship
  annotations_aggregate(
    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotations_aggregate!

  # An array relationship connection
  annotations_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotationsConnection!
  approved_by: uuid
  date_approved: timestamptz!
  date_reviewed: timestamptz!
  date_uploaded: timestamptz!
  file: bytea!
  id: ID!

  # An object relationship
  package_request: cpf_package_requests!
  package_request_id: uuid!
  reviewed_by: uuid
  uploaded_by: uuid!
}

# aggregated selection of "cpf.package_responses"
type cpf_package_responses_aggregate {
  aggregate: cpf_package_responses_aggregate_fields
  nodes: [cpf_package_responses!]!
}

# aggregate fields of "cpf.package_responses"
type cpf_package_responses_aggregate_fields {
  count(columns: [cpf_package_responses_select_column!], distinct: Boolean): Int
  max: cpf_package_responses_max_fields
  min: cpf_package_responses_min_fields
}

# order by aggregate values of table "cpf.package_responses"
input cpf_package_responses_aggregate_order_by {
  count: order_by
  max: cpf_package_responses_max_order_by
  min: cpf_package_responses_min_order_by
}

# input type for inserting array relation for remote table "cpf.package_responses"
input cpf_package_responses_arr_rel_insert_input {
  data: [cpf_package_responses_insert_input!]!
  on_conflict: cpf_package_responses_on_conflict
}

# Boolean expression to filter rows from the table "cpf.package_responses". All fields are combined with a logical 'AND'.
input cpf_package_responses_bool_exp {
  _and: [cpf_package_responses_bool_exp]
  _not: cpf_package_responses_bool_exp
  _or: [cpf_package_responses_bool_exp]
  annotations: cpf_annotations_bool_exp
  approved_by: uuid_comparison_exp
  date_approved: timestamptz_comparison_exp
  date_reviewed: timestamptz_comparison_exp
  date_uploaded: timestamptz_comparison_exp
  file: bytea_comparison_exp
  id: uuid_comparison_exp
  package_request: cpf_package_requests_bool_exp
  package_request_id: uuid_comparison_exp
  reviewed_by: uuid_comparison_exp
  uploaded_by: uuid_comparison_exp
}

# unique or primary key constraints on table "cpf.package_responses"
enum cpf_package_responses_constraint {
  # unique or primary key constraint
  package_responses_pkey
}

# input type for inserting data into table "cpf.package_responses"
input cpf_package_responses_insert_input {
  annotations: cpf_annotations_arr_rel_insert_input
  approved_by: uuid
  date_approved: timestamptz
  date_reviewed: timestamptz
  date_uploaded: timestamptz
  file: bytea
  id: uuid
  package_request: cpf_package_requests_obj_rel_insert_input
  package_request_id: uuid
  reviewed_by: uuid
  uploaded_by: uuid
}

# aggregate max on columns
type cpf_package_responses_max_fields {
  approved_by: uuid
  date_approved: timestamptz
  date_reviewed: timestamptz
  date_uploaded: timestamptz
  id: uuid
  package_request_id: uuid
  reviewed_by: uuid
  uploaded_by: uuid
}

# order by max() on columns of table "cpf.package_responses"
input cpf_package_responses_max_order_by {
  approved_by: order_by
  date_approved: order_by
  date_reviewed: order_by
  date_uploaded: order_by
  id: order_by
  package_request_id: order_by
  reviewed_by: order_by
  uploaded_by: order_by
}

# aggregate min on columns
type cpf_package_responses_min_fields {
  approved_by: uuid
  date_approved: timestamptz
  date_reviewed: timestamptz
  date_uploaded: timestamptz
  id: uuid
  package_request_id: uuid
  reviewed_by: uuid
  uploaded_by: uuid
}

# order by min() on columns of table "cpf.package_responses"
input cpf_package_responses_min_order_by {
  approved_by: order_by
  date_approved: order_by
  date_reviewed: order_by
  date_uploaded: order_by
  id: order_by
  package_request_id: order_by
  reviewed_by: order_by
  uploaded_by: order_by
}

# response of any mutation on the table "cpf.package_responses"
type cpf_package_responses_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_package_responses!]!
}

# input type for inserting object relation for remote table "cpf.package_responses"
input cpf_package_responses_obj_rel_insert_input {
  data: cpf_package_responses_insert_input!
  on_conflict: cpf_package_responses_on_conflict
}

# on conflict condition type for table "cpf.package_responses"
input cpf_package_responses_on_conflict {
  constraint: cpf_package_responses_constraint!
  update_columns: [cpf_package_responses_update_column!]!
  where: cpf_package_responses_bool_exp
}

# ordering options when selecting data from "cpf.package_responses"
input cpf_package_responses_order_by {
  annotations_aggregate: cpf_annotations_aggregate_order_by
  approved_by: order_by
  date_approved: order_by
  date_reviewed: order_by
  date_uploaded: order_by
  file: order_by
  id: order_by
  package_request: cpf_package_requests_order_by
  package_request_id: order_by
  reviewed_by: order_by
  uploaded_by: order_by
}

# primary key columns input for table: "cpf.package_responses"
input cpf_package_responses_pk_columns_input {
  id: uuid!
}

# select columns of table "cpf.package_responses"
enum cpf_package_responses_select_column {
  # column name
  approved_by

  # column name
  date_approved

  # column name
  date_reviewed

  # column name
  date_uploaded

  # column name
  file

  # column name
  id

  # column name
  package_request_id

  # column name
  reviewed_by

  # column name
  uploaded_by
}

# input type for updating data in table "cpf.package_responses"
input cpf_package_responses_set_input {
  approved_by: uuid
  date_approved: timestamptz
  date_reviewed: timestamptz
  date_uploaded: timestamptz
  file: bytea
  id: uuid
  package_request_id: uuid
  reviewed_by: uuid
  uploaded_by: uuid
}

# update columns of table "cpf.package_responses"
enum cpf_package_responses_update_column {
  # column name
  approved_by

  # column name
  date_approved

  # column name
  date_reviewed

  # column name
  date_uploaded

  # column name
  file

  # column name
  id

  # column name
  package_request_id

  # column name
  reviewed_by

  # column name
  uploaded_by
}

# A Relay Connection object on "cpf.package_responses"
type cpf_package_responsesConnection {
  edges: [cpf_package_responsesEdge!]!
  pageInfo: PageInfo!
}

type cpf_package_responsesEdge {
  cursor: String!
  node: cpf_package_responses!
}

# columns and relationships of "cpf.packages"
type cpf_packages implements Node {
  # An array relationship
  annotations(
    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): [cpf_annotations!]!

  # An aggregated array relationship
  annotations_aggregate(
    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotations_aggregate!

  # An array relationship connection
  annotations_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotationsConnection!
  create_date: timestamptz!
  created_by: uuid!

  # An object relationship
  customer: cpf_customers!
  customer_id: uuid!
  id: ID!
  name: String

  # An array relationship
  package_requests(
    # distinct select on columns
    distinct_on: [cpf_package_requests_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_package_requests_order_by!]

    # filter the rows returned
    where: cpf_package_requests_bool_exp
  ): [cpf_package_requests!]!

  # An aggregated array relationship
  package_requests_aggregate(
    # distinct select on columns
    distinct_on: [cpf_package_requests_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_package_requests_order_by!]

    # filter the rows returned
    where: cpf_package_requests_bool_exp
  ): cpf_package_requests_aggregate!

  # An array relationship connection
  package_requests_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_package_requests_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_package_requests_order_by!]

    # filter the rows returned
    where: cpf_package_requests_bool_exp
  ): cpf_package_requestsConnection!

  # An object relationship
  user: cpf_users!
}

# aggregated selection of "cpf.packages"
type cpf_packages_aggregate {
  aggregate: cpf_packages_aggregate_fields
  nodes: [cpf_packages!]!
}

# aggregate fields of "cpf.packages"
type cpf_packages_aggregate_fields {
  count(columns: [cpf_packages_select_column!], distinct: Boolean): Int
  max: cpf_packages_max_fields
  min: cpf_packages_min_fields
}

# order by aggregate values of table "cpf.packages"
input cpf_packages_aggregate_order_by {
  count: order_by
  max: cpf_packages_max_order_by
  min: cpf_packages_min_order_by
}

# input type for inserting array relation for remote table "cpf.packages"
input cpf_packages_arr_rel_insert_input {
  data: [cpf_packages_insert_input!]!
  on_conflict: cpf_packages_on_conflict
}

# Boolean expression to filter rows from the table "cpf.packages". All fields are combined with a logical 'AND'.
input cpf_packages_bool_exp {
  _and: [cpf_packages_bool_exp]
  _not: cpf_packages_bool_exp
  _or: [cpf_packages_bool_exp]
  annotations: cpf_annotations_bool_exp
  create_date: timestamptz_comparison_exp
  created_by: uuid_comparison_exp
  customer: cpf_customers_bool_exp
  customer_id: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  package_requests: cpf_package_requests_bool_exp
  user: cpf_users_bool_exp
}

# unique or primary key constraints on table "cpf.packages"
enum cpf_packages_constraint {
  # unique or primary key constraint
  packages_pkey
}

# input type for inserting data into table "cpf.packages"
input cpf_packages_insert_input {
  annotations: cpf_annotations_arr_rel_insert_input
  create_date: timestamptz
  created_by: uuid
  customer: cpf_customers_obj_rel_insert_input
  customer_id: uuid
  id: uuid
  name: String
  package_requests: cpf_package_requests_arr_rel_insert_input
  user: cpf_users_obj_rel_insert_input
}

# aggregate max on columns
type cpf_packages_max_fields {
  create_date: timestamptz
  created_by: uuid
  customer_id: uuid
  id: uuid
  name: String
}

# order by max() on columns of table "cpf.packages"
input cpf_packages_max_order_by {
  create_date: order_by
  created_by: order_by
  customer_id: order_by
  id: order_by
  name: order_by
}

# aggregate min on columns
type cpf_packages_min_fields {
  create_date: timestamptz
  created_by: uuid
  customer_id: uuid
  id: uuid
  name: String
}

# order by min() on columns of table "cpf.packages"
input cpf_packages_min_order_by {
  create_date: order_by
  created_by: order_by
  customer_id: order_by
  id: order_by
  name: order_by
}

# response of any mutation on the table "cpf.packages"
type cpf_packages_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_packages!]!
}

# input type for inserting object relation for remote table "cpf.packages"
input cpf_packages_obj_rel_insert_input {
  data: cpf_packages_insert_input!
  on_conflict: cpf_packages_on_conflict
}

# on conflict condition type for table "cpf.packages"
input cpf_packages_on_conflict {
  constraint: cpf_packages_constraint!
  update_columns: [cpf_packages_update_column!]!
  where: cpf_packages_bool_exp
}

# ordering options when selecting data from "cpf.packages"
input cpf_packages_order_by {
  annotations_aggregate: cpf_annotations_aggregate_order_by
  create_date: order_by
  created_by: order_by
  customer: cpf_customers_order_by
  customer_id: order_by
  id: order_by
  name: order_by
  package_requests_aggregate: cpf_package_requests_aggregate_order_by
  user: cpf_users_order_by
}

# primary key columns input for table: "cpf.packages"
input cpf_packages_pk_columns_input {
  id: uuid!
}

# select columns of table "cpf.packages"
enum cpf_packages_select_column {
  # column name
  create_date

  # column name
  created_by

  # column name
  customer_id

  # column name
  id

  # column name
  name
}

# input type for updating data in table "cpf.packages"
input cpf_packages_set_input {
  create_date: timestamptz
  created_by: uuid
  customer_id: uuid
  id: uuid
  name: String
}

# update columns of table "cpf.packages"
enum cpf_packages_update_column {
  # column name
  create_date

  # column name
  created_by

  # column name
  customer_id

  # column name
  id

  # column name
  name
}

# A Relay Connection object on "cpf.packages"
type cpf_packagesConnection {
  edges: [cpf_packagesEdge!]!
  pageInfo: PageInfo!
}

type cpf_packagesEdge {
  cursor: String!
  node: cpf_packages!
}

# columns and relationships of "cpf.regions"
type cpf_regions implements Node {
  abbreviation: String

  # An array relationship
  annotations(
    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): [cpf_annotations!]!

  # An aggregated array relationship
  annotations_aggregate(
    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotations_aggregate!

  # An array relationship connection
  annotations_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotationsConnection!

  # An array relationship
  custom_forms_library_regions(
    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_regions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_regions_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_regions_bool_exp
  ): [cpf_custom_forms_library_regions!]!

  # An aggregated array relationship
  custom_forms_library_regions_aggregate(
    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_regions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_regions_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_regions_bool_exp
  ): cpf_custom_forms_library_regions_aggregate!

  # An array relationship connection
  custom_forms_library_regions_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_regions_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_regions_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_regions_bool_exp
  ): cpf_custom_forms_library_regionsConnection!
  id: ID!
  name: String!

  # An object relationship
  tenant: cpf_tenants
  tenant_id: uuid
}

# aggregated selection of "cpf.regions"
type cpf_regions_aggregate {
  aggregate: cpf_regions_aggregate_fields
  nodes: [cpf_regions!]!
}

# aggregate fields of "cpf.regions"
type cpf_regions_aggregate_fields {
  count(columns: [cpf_regions_select_column!], distinct: Boolean): Int
  max: cpf_regions_max_fields
  min: cpf_regions_min_fields
}

# order by aggregate values of table "cpf.regions"
input cpf_regions_aggregate_order_by {
  count: order_by
  max: cpf_regions_max_order_by
  min: cpf_regions_min_order_by
}

# input type for inserting array relation for remote table "cpf.regions"
input cpf_regions_arr_rel_insert_input {
  data: [cpf_regions_insert_input!]!
  on_conflict: cpf_regions_on_conflict
}

# Boolean expression to filter rows from the table "cpf.regions". All fields are combined with a logical 'AND'.
input cpf_regions_bool_exp {
  _and: [cpf_regions_bool_exp]
  _not: cpf_regions_bool_exp
  _or: [cpf_regions_bool_exp]
  abbreviation: String_comparison_exp
  annotations: cpf_annotations_bool_exp
  custom_forms_library_regions: cpf_custom_forms_library_regions_bool_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  tenant: cpf_tenants_bool_exp
  tenant_id: uuid_comparison_exp
}

# unique or primary key constraints on table "cpf.regions"
enum cpf_regions_constraint {
  # unique or primary key constraint
  regions_pkey
}

# input type for inserting data into table "cpf.regions"
input cpf_regions_insert_input {
  abbreviation: String
  annotations: cpf_annotations_arr_rel_insert_input
  custom_forms_library_regions: cpf_custom_forms_library_regions_arr_rel_insert_input
  id: uuid
  name: String
  tenant: cpf_tenants_obj_rel_insert_input
  tenant_id: uuid
}

# aggregate max on columns
type cpf_regions_max_fields {
  abbreviation: String
  id: uuid
  name: String
  tenant_id: uuid
}

# order by max() on columns of table "cpf.regions"
input cpf_regions_max_order_by {
  abbreviation: order_by
  id: order_by
  name: order_by
  tenant_id: order_by
}

# aggregate min on columns
type cpf_regions_min_fields {
  abbreviation: String
  id: uuid
  name: String
  tenant_id: uuid
}

# order by min() on columns of table "cpf.regions"
input cpf_regions_min_order_by {
  abbreviation: order_by
  id: order_by
  name: order_by
  tenant_id: order_by
}

# response of any mutation on the table "cpf.regions"
type cpf_regions_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_regions!]!
}

# input type for inserting object relation for remote table "cpf.regions"
input cpf_regions_obj_rel_insert_input {
  data: cpf_regions_insert_input!
  on_conflict: cpf_regions_on_conflict
}

# on conflict condition type for table "cpf.regions"
input cpf_regions_on_conflict {
  constraint: cpf_regions_constraint!
  update_columns: [cpf_regions_update_column!]!
  where: cpf_regions_bool_exp
}

# ordering options when selecting data from "cpf.regions"
input cpf_regions_order_by {
  abbreviation: order_by
  annotations_aggregate: cpf_annotations_aggregate_order_by
  custom_forms_library_regions_aggregate: cpf_custom_forms_library_regions_aggregate_order_by
  id: order_by
  name: order_by
  tenant: cpf_tenants_order_by
  tenant_id: order_by
}

# primary key columns input for table: "cpf.regions"
input cpf_regions_pk_columns_input {
  id: uuid!
}

# select columns of table "cpf.regions"
enum cpf_regions_select_column {
  # column name
  abbreviation

  # column name
  id

  # column name
  name

  # column name
  tenant_id
}

# input type for updating data in table "cpf.regions"
input cpf_regions_set_input {
  abbreviation: String
  id: uuid
  name: String
  tenant_id: uuid
}

# update columns of table "cpf.regions"
enum cpf_regions_update_column {
  # column name
  abbreviation

  # column name
  id

  # column name
  name

  # column name
  tenant_id
}

# A Relay Connection object on "cpf.regions"
type cpf_regionsConnection {
  edges: [cpf_regionsEdge!]!
  pageInfo: PageInfo!
}

type cpf_regionsEdge {
  cursor: String!
  node: cpf_regions!
}

# columns and relationships of "cpf.tax_types"
type cpf_tax_types implements Node {
  comment: String!

  # An array relationship
  custom_forms_library_tax_types(
    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_tax_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_tax_types_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_tax_types_bool_exp
  ): [cpf_custom_forms_library_tax_types!]!

  # An aggregated array relationship
  custom_forms_library_tax_types_aggregate(
    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_tax_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_tax_types_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_tax_types_bool_exp
  ): cpf_custom_forms_library_tax_types_aggregate!

  # An array relationship connection
  custom_forms_library_tax_types_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_tax_types_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_tax_types_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_tax_types_bool_exp
  ): cpf_custom_forms_library_tax_typesConnection!
  id: ID!
}

# aggregated selection of "cpf.tax_types"
type cpf_tax_types_aggregate {
  aggregate: cpf_tax_types_aggregate_fields
  nodes: [cpf_tax_types!]!
}

# aggregate fields of "cpf.tax_types"
type cpf_tax_types_aggregate_fields {
  count(columns: [cpf_tax_types_select_column!], distinct: Boolean): Int
  max: cpf_tax_types_max_fields
  min: cpf_tax_types_min_fields
}

# order by aggregate values of table "cpf.tax_types"
input cpf_tax_types_aggregate_order_by {
  count: order_by
  max: cpf_tax_types_max_order_by
  min: cpf_tax_types_min_order_by
}

# input type for inserting array relation for remote table "cpf.tax_types"
input cpf_tax_types_arr_rel_insert_input {
  data: [cpf_tax_types_insert_input!]!
  on_conflict: cpf_tax_types_on_conflict
}

# Boolean expression to filter rows from the table "cpf.tax_types". All fields are combined with a logical 'AND'.
input cpf_tax_types_bool_exp {
  _and: [cpf_tax_types_bool_exp]
  _not: cpf_tax_types_bool_exp
  _or: [cpf_tax_types_bool_exp]
  comment: String_comparison_exp
  custom_forms_library_tax_types: cpf_custom_forms_library_tax_types_bool_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "cpf.tax_types"
enum cpf_tax_types_constraint {
  # unique or primary key constraint
  tax_types_pkey
}

enum cpf_tax_types_enum {
  # invalid
  do_not_use
}

# expression to compare columns of type cpf_tax_types_enum. All fields are combined with logical 'AND'.
input cpf_tax_types_enum_comparison_exp {
  _eq: cpf_tax_types_enum
  _in: [cpf_tax_types_enum!]
  _is_null: Boolean
  _neq: cpf_tax_types_enum
  _nin: [cpf_tax_types_enum!]
}

# input type for inserting data into table "cpf.tax_types"
input cpf_tax_types_insert_input {
  comment: String
  custom_forms_library_tax_types: cpf_custom_forms_library_tax_types_arr_rel_insert_input
  id: String
}

# aggregate max on columns
type cpf_tax_types_max_fields {
  comment: String
  id: String
}

# order by max() on columns of table "cpf.tax_types"
input cpf_tax_types_max_order_by {
  comment: order_by
  id: order_by
}

# aggregate min on columns
type cpf_tax_types_min_fields {
  comment: String
  id: String
}

# order by min() on columns of table "cpf.tax_types"
input cpf_tax_types_min_order_by {
  comment: order_by
  id: order_by
}

# response of any mutation on the table "cpf.tax_types"
type cpf_tax_types_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_tax_types!]!
}

# input type for inserting object relation for remote table "cpf.tax_types"
input cpf_tax_types_obj_rel_insert_input {
  data: cpf_tax_types_insert_input!
  on_conflict: cpf_tax_types_on_conflict
}

# on conflict condition type for table "cpf.tax_types"
input cpf_tax_types_on_conflict {
  constraint: cpf_tax_types_constraint!
  update_columns: [cpf_tax_types_update_column!]!
  where: cpf_tax_types_bool_exp
}

# ordering options when selecting data from "cpf.tax_types"
input cpf_tax_types_order_by {
  comment: order_by
  custom_forms_library_tax_types_aggregate: cpf_custom_forms_library_tax_types_aggregate_order_by
  id: order_by
}

# primary key columns input for table: "cpf.tax_types"
input cpf_tax_types_pk_columns_input {
  id: String!
}

# select columns of table "cpf.tax_types"
enum cpf_tax_types_select_column {
  # column name
  comment

  # column name
  id
}

# input type for updating data in table "cpf.tax_types"
input cpf_tax_types_set_input {
  comment: String
  id: String
}

# update columns of table "cpf.tax_types"
enum cpf_tax_types_update_column {
  # column name
  comment

  # column name
  id
}

# A Relay Connection object on "cpf.tax_types"
type cpf_tax_typesConnection {
  edges: [cpf_tax_typesEdge!]!
  pageInfo: PageInfo!
}

type cpf_tax_typesEdge {
  cursor: String!
  node: cpf_tax_types!
}

# columns and relationships of "cpf.tenants"
type cpf_tenants implements Node {
  # An array relationship
  annotations(
    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): [cpf_annotations!]!

  # An aggregated array relationship
  annotations_aggregate(
    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotations_aggregate!

  # An array relationship connection
  annotations_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotationsConnection!
  domain_prefix: bpchar!

  # An array relationship
  email_templates(
    # distinct select on columns
    distinct_on: [cpf_email_templates_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_email_templates_order_by!]

    # filter the rows returned
    where: cpf_email_templates_bool_exp
  ): [cpf_email_templates!]!

  # An aggregated array relationship
  email_templates_aggregate(
    # distinct select on columns
    distinct_on: [cpf_email_templates_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_email_templates_order_by!]

    # filter the rows returned
    where: cpf_email_templates_bool_exp
  ): cpf_email_templates_aggregate!

  # An array relationship connection
  email_templates_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_email_templates_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_email_templates_order_by!]

    # filter the rows returned
    where: cpf_email_templates_bool_exp
  ): cpf_email_templatesConnection!
  id: ID!
  name: String!

  # An array relationship
  regions(
    # distinct select on columns
    distinct_on: [cpf_regions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_regions_order_by!]

    # filter the rows returned
    where: cpf_regions_bool_exp
  ): [cpf_regions!]!

  # An aggregated array relationship
  regions_aggregate(
    # distinct select on columns
    distinct_on: [cpf_regions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_regions_order_by!]

    # filter the rows returned
    where: cpf_regions_bool_exp
  ): cpf_regions_aggregate!

  # An array relationship connection
  regions_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_regions_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_regions_order_by!]

    # filter the rows returned
    where: cpf_regions_bool_exp
  ): cpf_regionsConnection!

  # An array relationship
  tenants_users(
    # distinct select on columns
    distinct_on: [cpf_tenants_users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_tenants_users_order_by!]

    # filter the rows returned
    where: cpf_tenants_users_bool_exp
  ): [cpf_tenants_users!]!

  # An aggregated array relationship
  tenants_users_aggregate(
    # distinct select on columns
    distinct_on: [cpf_tenants_users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_tenants_users_order_by!]

    # filter the rows returned
    where: cpf_tenants_users_bool_exp
  ): cpf_tenants_users_aggregate!

  # An array relationship connection
  tenants_users_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_tenants_users_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_tenants_users_order_by!]

    # filter the rows returned
    where: cpf_tenants_users_bool_exp
  ): cpf_tenants_usersConnection!
}

# aggregated selection of "cpf.tenants"
type cpf_tenants_aggregate {
  aggregate: cpf_tenants_aggregate_fields
  nodes: [cpf_tenants!]!
}

# aggregate fields of "cpf.tenants"
type cpf_tenants_aggregate_fields {
  count(columns: [cpf_tenants_select_column!], distinct: Boolean): Int
  max: cpf_tenants_max_fields
  min: cpf_tenants_min_fields
}

# order by aggregate values of table "cpf.tenants"
input cpf_tenants_aggregate_order_by {
  count: order_by
  max: cpf_tenants_max_order_by
  min: cpf_tenants_min_order_by
}

# input type for inserting array relation for remote table "cpf.tenants"
input cpf_tenants_arr_rel_insert_input {
  data: [cpf_tenants_insert_input!]!
  on_conflict: cpf_tenants_on_conflict
}

# Boolean expression to filter rows from the table "cpf.tenants". All fields are combined with a logical 'AND'.
input cpf_tenants_bool_exp {
  _and: [cpf_tenants_bool_exp]
  _not: cpf_tenants_bool_exp
  _or: [cpf_tenants_bool_exp]
  annotations: cpf_annotations_bool_exp
  domain_prefix: bpchar_comparison_exp
  email_templates: cpf_email_templates_bool_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  regions: cpf_regions_bool_exp
  tenants_users: cpf_tenants_users_bool_exp
}

# unique or primary key constraints on table "cpf.tenants"
enum cpf_tenants_constraint {
  # unique or primary key constraint
  tenants_pkey
}

# input type for inserting data into table "cpf.tenants"
input cpf_tenants_insert_input {
  annotations: cpf_annotations_arr_rel_insert_input
  domain_prefix: bpchar
  email_templates: cpf_email_templates_arr_rel_insert_input
  id: uuid
  name: String
  regions: cpf_regions_arr_rel_insert_input
  tenants_users: cpf_tenants_users_arr_rel_insert_input
}

# aggregate max on columns
type cpf_tenants_max_fields {
  id: uuid
  name: String
}

# order by max() on columns of table "cpf.tenants"
input cpf_tenants_max_order_by {
  id: order_by
  name: order_by
}

# aggregate min on columns
type cpf_tenants_min_fields {
  id: uuid
  name: String
}

# order by min() on columns of table "cpf.tenants"
input cpf_tenants_min_order_by {
  id: order_by
  name: order_by
}

# response of any mutation on the table "cpf.tenants"
type cpf_tenants_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_tenants!]!
}

# input type for inserting object relation for remote table "cpf.tenants"
input cpf_tenants_obj_rel_insert_input {
  data: cpf_tenants_insert_input!
  on_conflict: cpf_tenants_on_conflict
}

# on conflict condition type for table "cpf.tenants"
input cpf_tenants_on_conflict {
  constraint: cpf_tenants_constraint!
  update_columns: [cpf_tenants_update_column!]!
  where: cpf_tenants_bool_exp
}

# ordering options when selecting data from "cpf.tenants"
input cpf_tenants_order_by {
  annotations_aggregate: cpf_annotations_aggregate_order_by
  domain_prefix: order_by
  email_templates_aggregate: cpf_email_templates_aggregate_order_by
  id: order_by
  name: order_by
  regions_aggregate: cpf_regions_aggregate_order_by
  tenants_users_aggregate: cpf_tenants_users_aggregate_order_by
}

# primary key columns input for table: "cpf.tenants"
input cpf_tenants_pk_columns_input {
  id: uuid!
}

# select columns of table "cpf.tenants"
enum cpf_tenants_select_column {
  # column name
  domain_prefix

  # column name
  id

  # column name
  name
}

# input type for updating data in table "cpf.tenants"
input cpf_tenants_set_input {
  domain_prefix: bpchar
  id: uuid
  name: String
}

# update columns of table "cpf.tenants"
enum cpf_tenants_update_column {
  # column name
  domain_prefix

  # column name
  id

  # column name
  name
}

# columns and relationships of "cpf.tenants_users"
type cpf_tenants_users implements Node {
  id: ID!

  # An object relationship
  tenant: cpf_tenants!
  tenant_id: uuid!

  # An object relationship
  user: cpf_users!
  user_id: uuid!
}

# aggregated selection of "cpf.tenants_users"
type cpf_tenants_users_aggregate {
  aggregate: cpf_tenants_users_aggregate_fields
  nodes: [cpf_tenants_users!]!
}

# aggregate fields of "cpf.tenants_users"
type cpf_tenants_users_aggregate_fields {
  count(columns: [cpf_tenants_users_select_column!], distinct: Boolean): Int
  max: cpf_tenants_users_max_fields
  min: cpf_tenants_users_min_fields
}

# order by aggregate values of table "cpf.tenants_users"
input cpf_tenants_users_aggregate_order_by {
  count: order_by
  max: cpf_tenants_users_max_order_by
  min: cpf_tenants_users_min_order_by
}

# input type for inserting array relation for remote table "cpf.tenants_users"
input cpf_tenants_users_arr_rel_insert_input {
  data: [cpf_tenants_users_insert_input!]!
  on_conflict: cpf_tenants_users_on_conflict
}

# Boolean expression to filter rows from the table "cpf.tenants_users". All fields are combined with a logical 'AND'.
input cpf_tenants_users_bool_exp {
  _and: [cpf_tenants_users_bool_exp]
  _not: cpf_tenants_users_bool_exp
  _or: [cpf_tenants_users_bool_exp]
  id: uuid_comparison_exp
  tenant: cpf_tenants_bool_exp
  tenant_id: uuid_comparison_exp
  user: cpf_users_bool_exp
  user_id: uuid_comparison_exp
}

# unique or primary key constraints on table "cpf.tenants_users"
enum cpf_tenants_users_constraint {
  # unique or primary key constraint
  tenants_users_pkey

  # unique or primary key constraint
  tenants_users_tenant_id_user_id_key
}

# input type for inserting data into table "cpf.tenants_users"
input cpf_tenants_users_insert_input {
  id: uuid
  tenant: cpf_tenants_obj_rel_insert_input
  tenant_id: uuid
  user: cpf_users_obj_rel_insert_input
  user_id: uuid
}

# aggregate max on columns
type cpf_tenants_users_max_fields {
  id: uuid
  tenant_id: uuid
  user_id: uuid
}

# order by max() on columns of table "cpf.tenants_users"
input cpf_tenants_users_max_order_by {
  id: order_by
  tenant_id: order_by
  user_id: order_by
}

# aggregate min on columns
type cpf_tenants_users_min_fields {
  id: uuid
  tenant_id: uuid
  user_id: uuid
}

# order by min() on columns of table "cpf.tenants_users"
input cpf_tenants_users_min_order_by {
  id: order_by
  tenant_id: order_by
  user_id: order_by
}

# response of any mutation on the table "cpf.tenants_users"
type cpf_tenants_users_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_tenants_users!]!
}

# input type for inserting object relation for remote table "cpf.tenants_users"
input cpf_tenants_users_obj_rel_insert_input {
  data: cpf_tenants_users_insert_input!
  on_conflict: cpf_tenants_users_on_conflict
}

# on conflict condition type for table "cpf.tenants_users"
input cpf_tenants_users_on_conflict {
  constraint: cpf_tenants_users_constraint!
  update_columns: [cpf_tenants_users_update_column!]!
  where: cpf_tenants_users_bool_exp
}

# ordering options when selecting data from "cpf.tenants_users"
input cpf_tenants_users_order_by {
  id: order_by
  tenant: cpf_tenants_order_by
  tenant_id: order_by
  user: cpf_users_order_by
  user_id: order_by
}

# primary key columns input for table: "cpf.tenants_users"
input cpf_tenants_users_pk_columns_input {
  id: uuid!
}

# select columns of table "cpf.tenants_users"
enum cpf_tenants_users_select_column {
  # column name
  id

  # column name
  tenant_id

  # column name
  user_id
}

# input type for updating data in table "cpf.tenants_users"
input cpf_tenants_users_set_input {
  id: uuid
  tenant_id: uuid
  user_id: uuid
}

# update columns of table "cpf.tenants_users"
enum cpf_tenants_users_update_column {
  # column name
  id

  # column name
  tenant_id

  # column name
  user_id
}

# A Relay Connection object on "cpf.tenants_users"
type cpf_tenants_usersConnection {
  edges: [cpf_tenants_usersEdge!]!
  pageInfo: PageInfo!
}

type cpf_tenants_usersEdge {
  cursor: String!
  node: cpf_tenants_users!
}

# A Relay Connection object on "cpf.tenants"
type cpf_tenantsConnection {
  edges: [cpf_tenantsEdge!]!
  pageInfo: PageInfo!
}

type cpf_tenantsEdge {
  cursor: String!
  node: cpf_tenants!
}

# columns and relationships of "cpf.user_roles"
type cpf_user_roles implements Node {
  comment: String!
  id: ID!

  # An array relationship
  users(
    # distinct select on columns
    distinct_on: [cpf_users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_users_order_by!]

    # filter the rows returned
    where: cpf_users_bool_exp
  ): [cpf_users!]!

  # An aggregated array relationship
  users_aggregate(
    # distinct select on columns
    distinct_on: [cpf_users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_users_order_by!]

    # filter the rows returned
    where: cpf_users_bool_exp
  ): cpf_users_aggregate!

  # An array relationship connection
  users_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_users_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_users_order_by!]

    # filter the rows returned
    where: cpf_users_bool_exp
  ): cpf_usersConnection!
}

# aggregated selection of "cpf.user_roles"
type cpf_user_roles_aggregate {
  aggregate: cpf_user_roles_aggregate_fields
  nodes: [cpf_user_roles!]!
}

# aggregate fields of "cpf.user_roles"
type cpf_user_roles_aggregate_fields {
  count(columns: [cpf_user_roles_select_column!], distinct: Boolean): Int
  max: cpf_user_roles_max_fields
  min: cpf_user_roles_min_fields
}

# order by aggregate values of table "cpf.user_roles"
input cpf_user_roles_aggregate_order_by {
  count: order_by
  max: cpf_user_roles_max_order_by
  min: cpf_user_roles_min_order_by
}

# input type for inserting array relation for remote table "cpf.user_roles"
input cpf_user_roles_arr_rel_insert_input {
  data: [cpf_user_roles_insert_input!]!
  on_conflict: cpf_user_roles_on_conflict
}

# Boolean expression to filter rows from the table "cpf.user_roles". All fields are combined with a logical 'AND'.
input cpf_user_roles_bool_exp {
  _and: [cpf_user_roles_bool_exp]
  _not: cpf_user_roles_bool_exp
  _or: [cpf_user_roles_bool_exp]
  comment: String_comparison_exp
  id: String_comparison_exp
  users: cpf_users_bool_exp
}

# unique or primary key constraints on table "cpf.user_roles"
enum cpf_user_roles_constraint {
  # unique or primary key constraint
  user_roles_pkey
}

enum cpf_user_roles_enum {
  # Administrators have review-only permissions for package request documents, but
  # are otherwise allowed to modify all other aspects of the main cpf site. They
  # are not allowed to access the self-service portal and should not be associated
  # with a customer number.
  administrator

  # This user has access to the customer self-service portal only. They must have
  # a customer number associated with them to use the portal. These users do not
  # have access to the main cpf app.
  customer_user

  # Supervisors have final approval permissions and are able to set package
  # requests to the "approved" status. They are not able to mark requests as
  # "reviewed", but they can "reject" them. These users have access to the main
  # cpf site but not the self-service portal.
  supervisor
}

# expression to compare columns of type cpf_user_roles_enum. All fields are combined with logical 'AND'.
input cpf_user_roles_enum_comparison_exp {
  _eq: cpf_user_roles_enum
  _in: [cpf_user_roles_enum!]
  _is_null: Boolean
  _neq: cpf_user_roles_enum
  _nin: [cpf_user_roles_enum!]
}

# input type for inserting data into table "cpf.user_roles"
input cpf_user_roles_insert_input {
  comment: String
  id: String
  users: cpf_users_arr_rel_insert_input
}

# aggregate max on columns
type cpf_user_roles_max_fields {
  comment: String
  id: String
}

# order by max() on columns of table "cpf.user_roles"
input cpf_user_roles_max_order_by {
  comment: order_by
  id: order_by
}

# aggregate min on columns
type cpf_user_roles_min_fields {
  comment: String
  id: String
}

# order by min() on columns of table "cpf.user_roles"
input cpf_user_roles_min_order_by {
  comment: order_by
  id: order_by
}

# response of any mutation on the table "cpf.user_roles"
type cpf_user_roles_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_user_roles!]!
}

# input type for inserting object relation for remote table "cpf.user_roles"
input cpf_user_roles_obj_rel_insert_input {
  data: cpf_user_roles_insert_input!
  on_conflict: cpf_user_roles_on_conflict
}

# on conflict condition type for table "cpf.user_roles"
input cpf_user_roles_on_conflict {
  constraint: cpf_user_roles_constraint!
  update_columns: [cpf_user_roles_update_column!]!
  where: cpf_user_roles_bool_exp
}

# ordering options when selecting data from "cpf.user_roles"
input cpf_user_roles_order_by {
  comment: order_by
  id: order_by
  users_aggregate: cpf_users_aggregate_order_by
}

# primary key columns input for table: "cpf.user_roles"
input cpf_user_roles_pk_columns_input {
  id: String!
}

# select columns of table "cpf.user_roles"
enum cpf_user_roles_select_column {
  # column name
  comment

  # column name
  id
}

# input type for updating data in table "cpf.user_roles"
input cpf_user_roles_set_input {
  comment: String
  id: String
}

# update columns of table "cpf.user_roles"
enum cpf_user_roles_update_column {
  # column name
  comment

  # column name
  id
}

# A Relay Connection object on "cpf.user_roles"
type cpf_user_rolesConnection {
  edges: [cpf_user_rolesEdge!]!
  pageInfo: PageInfo!
}

type cpf_user_rolesEdge {
  cursor: String!
  node: cpf_user_roles!
}

# columns and relationships of "cpf.users"
type cpf_users implements Node {
  # An array relationship
  annotations(
    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): [cpf_annotations!]!

  # An aggregated array relationship
  annotations_aggregate(
    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotations_aggregate!

  # An array relationship connection
  annotations_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotationsConnection!

  # An array relationship
  customersUsersByUserId(
    # distinct select on columns
    distinct_on: [cpf_customers_users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_customers_users_order_by!]

    # filter the rows returned
    where: cpf_customers_users_bool_exp
  ): [cpf_customers_users!]!

  # An aggregated array relationship
  customersUsersByUserId_aggregate(
    # distinct select on columns
    distinct_on: [cpf_customers_users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_customers_users_order_by!]

    # filter the rows returned
    where: cpf_customers_users_bool_exp
  ): cpf_customers_users_aggregate!

  # An array relationship connection
  customersUsersByUserId_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_customers_users_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_customers_users_order_by!]

    # filter the rows returned
    where: cpf_customers_users_bool_exp
  ): cpf_customers_usersConnection!
  customers_users: uuid!
  email_address: String!
  first_name: String!
  id: ID!
  last_name: String!

  # An array relationship
  packages(
    # distinct select on columns
    distinct_on: [cpf_packages_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_packages_order_by!]

    # filter the rows returned
    where: cpf_packages_bool_exp
  ): [cpf_packages!]!

  # An aggregated array relationship
  packages_aggregate(
    # distinct select on columns
    distinct_on: [cpf_packages_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_packages_order_by!]

    # filter the rows returned
    where: cpf_packages_bool_exp
  ): cpf_packages_aggregate!

  # An array relationship connection
  packages_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_packages_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_packages_order_by!]

    # filter the rows returned
    where: cpf_packages_bool_exp
  ): cpf_packagesConnection!
  receive_package_emails: Boolean!
  role: cpf_user_roles_enum!

  # An array relationship
  tenants_users(
    # distinct select on columns
    distinct_on: [cpf_tenants_users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_tenants_users_order_by!]

    # filter the rows returned
    where: cpf_tenants_users_bool_exp
  ): [cpf_tenants_users!]!

  # An aggregated array relationship
  tenants_users_aggregate(
    # distinct select on columns
    distinct_on: [cpf_tenants_users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cpf_tenants_users_order_by!]

    # filter the rows returned
    where: cpf_tenants_users_bool_exp
  ): cpf_tenants_users_aggregate!

  # An array relationship connection
  tenants_users_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_tenants_users_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_tenants_users_order_by!]

    # filter the rows returned
    where: cpf_tenants_users_bool_exp
  ): cpf_tenants_usersConnection!

  # An object relationship
  user_role: cpf_user_roles!
  username: String!
}

# aggregated selection of "cpf.users"
type cpf_users_aggregate {
  aggregate: cpf_users_aggregate_fields
  nodes: [cpf_users!]!
}

# aggregate fields of "cpf.users"
type cpf_users_aggregate_fields {
  count(columns: [cpf_users_select_column!], distinct: Boolean): Int
  max: cpf_users_max_fields
  min: cpf_users_min_fields
}

# order by aggregate values of table "cpf.users"
input cpf_users_aggregate_order_by {
  count: order_by
  max: cpf_users_max_order_by
  min: cpf_users_min_order_by
}

# input type for inserting array relation for remote table "cpf.users"
input cpf_users_arr_rel_insert_input {
  data: [cpf_users_insert_input!]!
  on_conflict: cpf_users_on_conflict
}

# Boolean expression to filter rows from the table "cpf.users". All fields are combined with a logical 'AND'.
input cpf_users_bool_exp {
  _and: [cpf_users_bool_exp]
  _not: cpf_users_bool_exp
  _or: [cpf_users_bool_exp]
  annotations: cpf_annotations_bool_exp
  customersUsersByUserId: cpf_customers_users_bool_exp
  customers_users: uuid_comparison_exp
  email_address: String_comparison_exp
  first_name: String_comparison_exp
  id: uuid_comparison_exp
  last_name: String_comparison_exp
  packages: cpf_packages_bool_exp
  receive_package_emails: Boolean_comparison_exp
  role: cpf_user_roles_enum_comparison_exp
  tenants_users: cpf_tenants_users_bool_exp
  user_role: cpf_user_roles_bool_exp
  username: String_comparison_exp
}

# unique or primary key constraints on table "cpf.users"
enum cpf_users_constraint {
  # unique or primary key constraint
  users_pkey
}

# input type for inserting data into table "cpf.users"
input cpf_users_insert_input {
  annotations: cpf_annotations_arr_rel_insert_input
  customersUsersByUserId: cpf_customers_users_arr_rel_insert_input
  customers_users: uuid
  email_address: String
  first_name: String
  id: uuid
  last_name: String
  packages: cpf_packages_arr_rel_insert_input
  receive_package_emails: Boolean
  role: cpf_user_roles_enum
  tenants_users: cpf_tenants_users_arr_rel_insert_input
  user_role: cpf_user_roles_obj_rel_insert_input
  username: String
}

# aggregate max on columns
type cpf_users_max_fields {
  customers_users: uuid
  email_address: String
  first_name: String
  id: uuid
  last_name: String
  username: String
}

# order by max() on columns of table "cpf.users"
input cpf_users_max_order_by {
  customers_users: order_by
  email_address: order_by
  first_name: order_by
  id: order_by
  last_name: order_by
  username: order_by
}

# aggregate min on columns
type cpf_users_min_fields {
  customers_users: uuid
  email_address: String
  first_name: String
  id: uuid
  last_name: String
  username: String
}

# order by min() on columns of table "cpf.users"
input cpf_users_min_order_by {
  customers_users: order_by
  email_address: order_by
  first_name: order_by
  id: order_by
  last_name: order_by
  username: order_by
}

# response of any mutation on the table "cpf.users"
type cpf_users_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cpf_users!]!
}

# input type for inserting object relation for remote table "cpf.users"
input cpf_users_obj_rel_insert_input {
  data: cpf_users_insert_input!
  on_conflict: cpf_users_on_conflict
}

# on conflict condition type for table "cpf.users"
input cpf_users_on_conflict {
  constraint: cpf_users_constraint!
  update_columns: [cpf_users_update_column!]!
  where: cpf_users_bool_exp
}

# ordering options when selecting data from "cpf.users"
input cpf_users_order_by {
  annotations_aggregate: cpf_annotations_aggregate_order_by
  customersUsersByUserId_aggregate: cpf_customers_users_aggregate_order_by
  customers_users: order_by
  email_address: order_by
  first_name: order_by
  id: order_by
  last_name: order_by
  packages_aggregate: cpf_packages_aggregate_order_by
  receive_package_emails: order_by
  role: order_by
  tenants_users_aggregate: cpf_tenants_users_aggregate_order_by
  user_role: cpf_user_roles_order_by
  username: order_by
}

# primary key columns input for table: "cpf.users"
input cpf_users_pk_columns_input {
  id: uuid!
}

# select columns of table "cpf.users"
enum cpf_users_select_column {
  # column name
  customers_users

  # column name
  email_address

  # column name
  first_name

  # column name
  id

  # column name
  last_name

  # column name
  receive_package_emails

  # column name
  role

  # column name
  username
}

# input type for updating data in table "cpf.users"
input cpf_users_set_input {
  customers_users: uuid
  email_address: String
  first_name: String
  id: uuid
  last_name: String
  receive_package_emails: Boolean
  role: cpf_user_roles_enum
  username: String
}

# update columns of table "cpf.users"
enum cpf_users_update_column {
  # column name
  customers_users

  # column name
  email_address

  # column name
  first_name

  # column name
  id

  # column name
  last_name

  # column name
  receive_package_emails

  # column name
  role

  # column name
  username
}

# A Relay Connection object on "cpf.users"
type cpf_usersConnection {
  edges: [cpf_usersEdge!]!
  pageInfo: PageInfo!
}

type cpf_usersEdge {
  cursor: String!
  node: cpf_users!
}

scalar date

# expression to compare columns of type date. All fields are combined with logical 'AND'.
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

scalar inet

# expression to compare columns of type inet. All fields are combined with logical 'AND'.
input inet_comparison_exp {
  _eq: inet
  _gt: inet
  _gte: inet
  _in: [inet!]
  _is_null: Boolean
  _lt: inet
  _lte: inet
  _neq: inet
  _nin: [inet!]
}

# expression to compare columns of type Int. All fields are combined with logical 'AND'.
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

scalar jsonb

# expression to compare columns of type jsonb. All fields are combined with logical 'AND'.
input jsonb_comparison_exp {
  # is the column contained in the given json value
  _contained_in: jsonb

  # does the column contain the given json value at the top level
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  # does the string exist as a top-level key in the column
  _has_key: String

  # do all of these strings exist as top-level keys in the column
  _has_keys_all: [String!]

  # do any of these strings exist as top-level keys in the column
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

# mutation root
type mutation_root {
  # delete data from the table: "audit.logged_actions"
  delete_audit_logged_actions(
    # filter the rows which have to be deleted
    where: audit_logged_actions_bool_exp!
  ): audit_logged_actions_mutation_response

  # delete single row from the table: "audit.logged_actions"
  delete_audit_logged_actions_by_pk(
    # Unique identifier for each auditable event
    event_id: bigint!
  ): audit_logged_actions

  # delete data from the table: "cpf.annotation_categories"
  delete_cpf_annotation_categories(
    # filter the rows which have to be deleted
    where: cpf_annotation_categories_bool_exp!
  ): cpf_annotation_categories_mutation_response

  # delete single row from the table: "cpf.annotation_categories"
  delete_cpf_annotation_categories_by_pk(id: String!): cpf_annotation_categories

  # delete data from the table: "cpf.annotations"
  delete_cpf_annotations(
    # filter the rows which have to be deleted
    where: cpf_annotations_bool_exp!
  ): cpf_annotations_mutation_response

  # delete single row from the table: "cpf.annotations"
  delete_cpf_annotations_by_pk(id: uuid!): cpf_annotations

  # delete data from the table: "cpf.custom_forms_library"
  delete_cpf_custom_forms_library(
    # filter the rows which have to be deleted
    where: cpf_custom_forms_library_bool_exp!
  ): cpf_custom_forms_library_mutation_response

  # delete single row from the table: "cpf.custom_forms_library"
  delete_cpf_custom_forms_library_by_pk(id: uuid!): cpf_custom_forms_library

  # delete data from the table: "cpf.custom_forms_library_file_versions"
  delete_cpf_custom_forms_library_file_versions(
    # filter the rows which have to be deleted
    where: cpf_custom_forms_library_file_versions_bool_exp!
  ): cpf_custom_forms_library_file_versions_mutation_response

  # delete single row from the table: "cpf.custom_forms_library_file_versions"
  delete_cpf_custom_forms_library_file_versions_by_pk(id: uuid!): cpf_custom_forms_library_file_versions

  # delete data from the table: "cpf.custom_forms_library_regions"
  delete_cpf_custom_forms_library_regions(
    # filter the rows which have to be deleted
    where: cpf_custom_forms_library_regions_bool_exp!
  ): cpf_custom_forms_library_regions_mutation_response

  # delete single row from the table: "cpf.custom_forms_library_regions"
  delete_cpf_custom_forms_library_regions_by_pk(id: uuid!): cpf_custom_forms_library_regions

  # delete data from the table: "cpf.custom_forms_library_tax_types"
  delete_cpf_custom_forms_library_tax_types(
    # filter the rows which have to be deleted
    where: cpf_custom_forms_library_tax_types_bool_exp!
  ): cpf_custom_forms_library_tax_types_mutation_response

  # delete single row from the table: "cpf.custom_forms_library_tax_types"
  delete_cpf_custom_forms_library_tax_types_by_pk(id: uuid!): cpf_custom_forms_library_tax_types

  # delete data from the table: "cpf.customers"
  delete_cpf_customers(
    # filter the rows which have to be deleted
    where: cpf_customers_bool_exp!
  ): cpf_customers_mutation_response

  # delete single row from the table: "cpf.customers"
  delete_cpf_customers_by_pk(id: uuid!): cpf_customers

  # delete data from the table: "cpf.customers_users"
  delete_cpf_customers_users(
    # filter the rows which have to be deleted
    where: cpf_customers_users_bool_exp!
  ): cpf_customers_users_mutation_response

  # delete single row from the table: "cpf.customers_users"
  delete_cpf_customers_users_by_pk(id: uuid!): cpf_customers_users

  # delete data from the table: "cpf.email_queue"
  delete_cpf_email_queue(
    # filter the rows which have to be deleted
    where: cpf_email_queue_bool_exp!
  ): cpf_email_queue_mutation_response

  # delete single row from the table: "cpf.email_queue"
  delete_cpf_email_queue_by_pk(id: uuid!): cpf_email_queue

  # delete data from the table: "cpf.email_status"
  delete_cpf_email_status(
    # filter the rows which have to be deleted
    where: cpf_email_status_bool_exp!
  ): cpf_email_status_mutation_response

  # delete single row from the table: "cpf.email_status"
  delete_cpf_email_status_by_pk(id: String!): cpf_email_status

  # delete data from the table: "cpf.email_templates"
  delete_cpf_email_templates(
    # filter the rows which have to be deleted
    where: cpf_email_templates_bool_exp!
  ): cpf_email_templates_mutation_response

  # delete single row from the table: "cpf.email_templates"
  delete_cpf_email_templates_by_pk(id: uuid!): cpf_email_templates

  # delete data from the table: "cpf.level"
  delete_cpf_level(
    # filter the rows which have to be deleted
    where: cpf_level_bool_exp!
  ): cpf_level_mutation_response

  # delete single row from the table: "cpf.level"
  delete_cpf_level_by_pk(id: String!): cpf_level

  # delete data from the table: "cpf.package_request_status"
  delete_cpf_package_request_status(
    # filter the rows which have to be deleted
    where: cpf_package_request_status_bool_exp!
  ): cpf_package_request_status_mutation_response

  # delete single row from the table: "cpf.package_request_status"
  delete_cpf_package_request_status_by_pk(id: String!): cpf_package_request_status

  # delete data from the table: "cpf.package_requests"
  delete_cpf_package_requests(
    # filter the rows which have to be deleted
    where: cpf_package_requests_bool_exp!
  ): cpf_package_requests_mutation_response

  # delete single row from the table: "cpf.package_requests"
  delete_cpf_package_requests_by_pk(id: uuid!): cpf_package_requests

  # delete data from the table: "cpf.package_responses"
  delete_cpf_package_responses(
    # filter the rows which have to be deleted
    where: cpf_package_responses_bool_exp!
  ): cpf_package_responses_mutation_response

  # delete single row from the table: "cpf.package_responses"
  delete_cpf_package_responses_by_pk(id: uuid!): cpf_package_responses

  # delete data from the table: "cpf.packages"
  delete_cpf_packages(
    # filter the rows which have to be deleted
    where: cpf_packages_bool_exp!
  ): cpf_packages_mutation_response

  # delete single row from the table: "cpf.packages"
  delete_cpf_packages_by_pk(id: uuid!): cpf_packages

  # delete data from the table: "cpf.regions"
  delete_cpf_regions(
    # filter the rows which have to be deleted
    where: cpf_regions_bool_exp!
  ): cpf_regions_mutation_response

  # delete single row from the table: "cpf.regions"
  delete_cpf_regions_by_pk(id: uuid!): cpf_regions

  # delete data from the table: "cpf.tax_types"
  delete_cpf_tax_types(
    # filter the rows which have to be deleted
    where: cpf_tax_types_bool_exp!
  ): cpf_tax_types_mutation_response

  # delete single row from the table: "cpf.tax_types"
  delete_cpf_tax_types_by_pk(id: String!): cpf_tax_types

  # delete data from the table: "cpf.tenants"
  delete_cpf_tenants(
    # filter the rows which have to be deleted
    where: cpf_tenants_bool_exp!
  ): cpf_tenants_mutation_response

  # delete single row from the table: "cpf.tenants"
  delete_cpf_tenants_by_pk(id: uuid!): cpf_tenants

  # delete data from the table: "cpf.tenants_users"
  delete_cpf_tenants_users(
    # filter the rows which have to be deleted
    where: cpf_tenants_users_bool_exp!
  ): cpf_tenants_users_mutation_response

  # delete single row from the table: "cpf.tenants_users"
  delete_cpf_tenants_users_by_pk(id: uuid!): cpf_tenants_users

  # delete data from the table: "cpf.user_roles"
  delete_cpf_user_roles(
    # filter the rows which have to be deleted
    where: cpf_user_roles_bool_exp!
  ): cpf_user_roles_mutation_response

  # delete single row from the table: "cpf.user_roles"
  delete_cpf_user_roles_by_pk(id: String!): cpf_user_roles

  # delete data from the table: "cpf.users"
  delete_cpf_users(
    # filter the rows which have to be deleted
    where: cpf_users_bool_exp!
  ): cpf_users_mutation_response

  # delete single row from the table: "cpf.users"
  delete_cpf_users_by_pk(id: uuid!): cpf_users

  # delete data from the table: "todo_app.todos"
  delete_todo_app_todos(
    # filter the rows which have to be deleted
    where: todo_app_todos_bool_exp!
  ): todo_app_todos_mutation_response

  # delete single row from the table: "todo_app.todos"
  delete_todo_app_todos_by_pk(todo_id: uuid!): todo_app_todos

  # delete data from the table: "todo_app.users"
  delete_todo_app_users(
    # filter the rows which have to be deleted
    where: todo_app_users_bool_exp!
  ): todo_app_users_mutation_response

  # delete single row from the table: "todo_app.users"
  delete_todo_app_users_by_pk(id: Int!): todo_app_users

  # insert data into the table: "audit.logged_actions"
  insert_audit_logged_actions(
    # the rows to be inserted
    objects: [audit_logged_actions_insert_input!]!

    # on conflict condition
    on_conflict: audit_logged_actions_on_conflict
  ): audit_logged_actions_mutation_response

  # insert a single row into the table: "audit.logged_actions"
  insert_audit_logged_actions_one(
    # the row to be inserted
    object: audit_logged_actions_insert_input!

    # on conflict condition
    on_conflict: audit_logged_actions_on_conflict
  ): audit_logged_actions

  # insert data into the table: "cpf.annotation_categories"
  insert_cpf_annotation_categories(
    # the rows to be inserted
    objects: [cpf_annotation_categories_insert_input!]!

    # on conflict condition
    on_conflict: cpf_annotation_categories_on_conflict
  ): cpf_annotation_categories_mutation_response

  # insert a single row into the table: "cpf.annotation_categories"
  insert_cpf_annotation_categories_one(
    # the row to be inserted
    object: cpf_annotation_categories_insert_input!

    # on conflict condition
    on_conflict: cpf_annotation_categories_on_conflict
  ): cpf_annotation_categories

  # insert data into the table: "cpf.annotations"
  insert_cpf_annotations(
    # the rows to be inserted
    objects: [cpf_annotations_insert_input!]!

    # on conflict condition
    on_conflict: cpf_annotations_on_conflict
  ): cpf_annotations_mutation_response

  # insert a single row into the table: "cpf.annotations"
  insert_cpf_annotations_one(
    # the row to be inserted
    object: cpf_annotations_insert_input!

    # on conflict condition
    on_conflict: cpf_annotations_on_conflict
  ): cpf_annotations

  # insert data into the table: "cpf.custom_forms_library"
  insert_cpf_custom_forms_library(
    # the rows to be inserted
    objects: [cpf_custom_forms_library_insert_input!]!

    # on conflict condition
    on_conflict: cpf_custom_forms_library_on_conflict
  ): cpf_custom_forms_library_mutation_response

  # insert data into the table: "cpf.custom_forms_library_file_versions"
  insert_cpf_custom_forms_library_file_versions(
    # the rows to be inserted
    objects: [cpf_custom_forms_library_file_versions_insert_input!]!

    # on conflict condition
    on_conflict: cpf_custom_forms_library_file_versions_on_conflict
  ): cpf_custom_forms_library_file_versions_mutation_response

  # insert a single row into the table: "cpf.custom_forms_library_file_versions"
  insert_cpf_custom_forms_library_file_versions_one(
    # the row to be inserted
    object: cpf_custom_forms_library_file_versions_insert_input!

    # on conflict condition
    on_conflict: cpf_custom_forms_library_file_versions_on_conflict
  ): cpf_custom_forms_library_file_versions

  # insert a single row into the table: "cpf.custom_forms_library"
  insert_cpf_custom_forms_library_one(
    # the row to be inserted
    object: cpf_custom_forms_library_insert_input!

    # on conflict condition
    on_conflict: cpf_custom_forms_library_on_conflict
  ): cpf_custom_forms_library

  # insert data into the table: "cpf.custom_forms_library_regions"
  insert_cpf_custom_forms_library_regions(
    # the rows to be inserted
    objects: [cpf_custom_forms_library_regions_insert_input!]!

    # on conflict condition
    on_conflict: cpf_custom_forms_library_regions_on_conflict
  ): cpf_custom_forms_library_regions_mutation_response

  # insert a single row into the table: "cpf.custom_forms_library_regions"
  insert_cpf_custom_forms_library_regions_one(
    # the row to be inserted
    object: cpf_custom_forms_library_regions_insert_input!

    # on conflict condition
    on_conflict: cpf_custom_forms_library_regions_on_conflict
  ): cpf_custom_forms_library_regions

  # insert data into the table: "cpf.custom_forms_library_tax_types"
  insert_cpf_custom_forms_library_tax_types(
    # the rows to be inserted
    objects: [cpf_custom_forms_library_tax_types_insert_input!]!

    # on conflict condition
    on_conflict: cpf_custom_forms_library_tax_types_on_conflict
  ): cpf_custom_forms_library_tax_types_mutation_response

  # insert a single row into the table: "cpf.custom_forms_library_tax_types"
  insert_cpf_custom_forms_library_tax_types_one(
    # the row to be inserted
    object: cpf_custom_forms_library_tax_types_insert_input!

    # on conflict condition
    on_conflict: cpf_custom_forms_library_tax_types_on_conflict
  ): cpf_custom_forms_library_tax_types

  # insert data into the table: "cpf.customers"
  insert_cpf_customers(
    # the rows to be inserted
    objects: [cpf_customers_insert_input!]!

    # on conflict condition
    on_conflict: cpf_customers_on_conflict
  ): cpf_customers_mutation_response

  # insert a single row into the table: "cpf.customers"
  insert_cpf_customers_one(
    # the row to be inserted
    object: cpf_customers_insert_input!

    # on conflict condition
    on_conflict: cpf_customers_on_conflict
  ): cpf_customers

  # insert data into the table: "cpf.customers_users"
  insert_cpf_customers_users(
    # the rows to be inserted
    objects: [cpf_customers_users_insert_input!]!

    # on conflict condition
    on_conflict: cpf_customers_users_on_conflict
  ): cpf_customers_users_mutation_response

  # insert a single row into the table: "cpf.customers_users"
  insert_cpf_customers_users_one(
    # the row to be inserted
    object: cpf_customers_users_insert_input!

    # on conflict condition
    on_conflict: cpf_customers_users_on_conflict
  ): cpf_customers_users

  # insert data into the table: "cpf.email_queue"
  insert_cpf_email_queue(
    # the rows to be inserted
    objects: [cpf_email_queue_insert_input!]!

    # on conflict condition
    on_conflict: cpf_email_queue_on_conflict
  ): cpf_email_queue_mutation_response

  # insert a single row into the table: "cpf.email_queue"
  insert_cpf_email_queue_one(
    # the row to be inserted
    object: cpf_email_queue_insert_input!

    # on conflict condition
    on_conflict: cpf_email_queue_on_conflict
  ): cpf_email_queue

  # insert data into the table: "cpf.email_status"
  insert_cpf_email_status(
    # the rows to be inserted
    objects: [cpf_email_status_insert_input!]!

    # on conflict condition
    on_conflict: cpf_email_status_on_conflict
  ): cpf_email_status_mutation_response

  # insert a single row into the table: "cpf.email_status"
  insert_cpf_email_status_one(
    # the row to be inserted
    object: cpf_email_status_insert_input!

    # on conflict condition
    on_conflict: cpf_email_status_on_conflict
  ): cpf_email_status

  # insert data into the table: "cpf.email_templates"
  insert_cpf_email_templates(
    # the rows to be inserted
    objects: [cpf_email_templates_insert_input!]!

    # on conflict condition
    on_conflict: cpf_email_templates_on_conflict
  ): cpf_email_templates_mutation_response

  # insert a single row into the table: "cpf.email_templates"
  insert_cpf_email_templates_one(
    # the row to be inserted
    object: cpf_email_templates_insert_input!

    # on conflict condition
    on_conflict: cpf_email_templates_on_conflict
  ): cpf_email_templates

  # insert data into the table: "cpf.level"
  insert_cpf_level(
    # the rows to be inserted
    objects: [cpf_level_insert_input!]!

    # on conflict condition
    on_conflict: cpf_level_on_conflict
  ): cpf_level_mutation_response

  # insert a single row into the table: "cpf.level"
  insert_cpf_level_one(
    # the row to be inserted
    object: cpf_level_insert_input!

    # on conflict condition
    on_conflict: cpf_level_on_conflict
  ): cpf_level

  # insert data into the table: "cpf.package_request_status"
  insert_cpf_package_request_status(
    # the rows to be inserted
    objects: [cpf_package_request_status_insert_input!]!

    # on conflict condition
    on_conflict: cpf_package_request_status_on_conflict
  ): cpf_package_request_status_mutation_response

  # insert a single row into the table: "cpf.package_request_status"
  insert_cpf_package_request_status_one(
    # the row to be inserted
    object: cpf_package_request_status_insert_input!

    # on conflict condition
    on_conflict: cpf_package_request_status_on_conflict
  ): cpf_package_request_status

  # insert data into the table: "cpf.package_requests"
  insert_cpf_package_requests(
    # the rows to be inserted
    objects: [cpf_package_requests_insert_input!]!

    # on conflict condition
    on_conflict: cpf_package_requests_on_conflict
  ): cpf_package_requests_mutation_response

  # insert a single row into the table: "cpf.package_requests"
  insert_cpf_package_requests_one(
    # the row to be inserted
    object: cpf_package_requests_insert_input!

    # on conflict condition
    on_conflict: cpf_package_requests_on_conflict
  ): cpf_package_requests

  # insert data into the table: "cpf.package_responses"
  insert_cpf_package_responses(
    # the rows to be inserted
    objects: [cpf_package_responses_insert_input!]!

    # on conflict condition
    on_conflict: cpf_package_responses_on_conflict
  ): cpf_package_responses_mutation_response

  # insert a single row into the table: "cpf.package_responses"
  insert_cpf_package_responses_one(
    # the row to be inserted
    object: cpf_package_responses_insert_input!

    # on conflict condition
    on_conflict: cpf_package_responses_on_conflict
  ): cpf_package_responses

  # insert data into the table: "cpf.packages"
  insert_cpf_packages(
    # the rows to be inserted
    objects: [cpf_packages_insert_input!]!

    # on conflict condition
    on_conflict: cpf_packages_on_conflict
  ): cpf_packages_mutation_response

  # insert a single row into the table: "cpf.packages"
  insert_cpf_packages_one(
    # the row to be inserted
    object: cpf_packages_insert_input!

    # on conflict condition
    on_conflict: cpf_packages_on_conflict
  ): cpf_packages

  # insert data into the table: "cpf.regions"
  insert_cpf_regions(
    # the rows to be inserted
    objects: [cpf_regions_insert_input!]!

    # on conflict condition
    on_conflict: cpf_regions_on_conflict
  ): cpf_regions_mutation_response

  # insert a single row into the table: "cpf.regions"
  insert_cpf_regions_one(
    # the row to be inserted
    object: cpf_regions_insert_input!

    # on conflict condition
    on_conflict: cpf_regions_on_conflict
  ): cpf_regions

  # insert data into the table: "cpf.tax_types"
  insert_cpf_tax_types(
    # the rows to be inserted
    objects: [cpf_tax_types_insert_input!]!

    # on conflict condition
    on_conflict: cpf_tax_types_on_conflict
  ): cpf_tax_types_mutation_response

  # insert a single row into the table: "cpf.tax_types"
  insert_cpf_tax_types_one(
    # the row to be inserted
    object: cpf_tax_types_insert_input!

    # on conflict condition
    on_conflict: cpf_tax_types_on_conflict
  ): cpf_tax_types

  # insert data into the table: "cpf.tenants"
  insert_cpf_tenants(
    # the rows to be inserted
    objects: [cpf_tenants_insert_input!]!

    # on conflict condition
    on_conflict: cpf_tenants_on_conflict
  ): cpf_tenants_mutation_response

  # insert a single row into the table: "cpf.tenants"
  insert_cpf_tenants_one(
    # the row to be inserted
    object: cpf_tenants_insert_input!

    # on conflict condition
    on_conflict: cpf_tenants_on_conflict
  ): cpf_tenants

  # insert data into the table: "cpf.tenants_users"
  insert_cpf_tenants_users(
    # the rows to be inserted
    objects: [cpf_tenants_users_insert_input!]!

    # on conflict condition
    on_conflict: cpf_tenants_users_on_conflict
  ): cpf_tenants_users_mutation_response

  # insert a single row into the table: "cpf.tenants_users"
  insert_cpf_tenants_users_one(
    # the row to be inserted
    object: cpf_tenants_users_insert_input!

    # on conflict condition
    on_conflict: cpf_tenants_users_on_conflict
  ): cpf_tenants_users

  # insert data into the table: "cpf.user_roles"
  insert_cpf_user_roles(
    # the rows to be inserted
    objects: [cpf_user_roles_insert_input!]!

    # on conflict condition
    on_conflict: cpf_user_roles_on_conflict
  ): cpf_user_roles_mutation_response

  # insert a single row into the table: "cpf.user_roles"
  insert_cpf_user_roles_one(
    # the row to be inserted
    object: cpf_user_roles_insert_input!

    # on conflict condition
    on_conflict: cpf_user_roles_on_conflict
  ): cpf_user_roles

  # insert data into the table: "cpf.users"
  insert_cpf_users(
    # the rows to be inserted
    objects: [cpf_users_insert_input!]!

    # on conflict condition
    on_conflict: cpf_users_on_conflict
  ): cpf_users_mutation_response

  # insert a single row into the table: "cpf.users"
  insert_cpf_users_one(
    # the row to be inserted
    object: cpf_users_insert_input!

    # on conflict condition
    on_conflict: cpf_users_on_conflict
  ): cpf_users

  # insert data into the table: "todo_app.todos"
  insert_todo_app_todos(
    # the rows to be inserted
    objects: [todo_app_todos_insert_input!]!

    # on conflict condition
    on_conflict: todo_app_todos_on_conflict
  ): todo_app_todos_mutation_response

  # insert a single row into the table: "todo_app.todos"
  insert_todo_app_todos_one(
    # the row to be inserted
    object: todo_app_todos_insert_input!

    # on conflict condition
    on_conflict: todo_app_todos_on_conflict
  ): todo_app_todos

  # insert data into the table: "todo_app.users"
  insert_todo_app_users(
    # the rows to be inserted
    objects: [todo_app_users_insert_input!]!

    # on conflict condition
    on_conflict: todo_app_users_on_conflict
  ): todo_app_users_mutation_response

  # insert a single row into the table: "todo_app.users"
  insert_todo_app_users_one(
    # the row to be inserted
    object: todo_app_users_insert_input!

    # on conflict condition
    on_conflict: todo_app_users_on_conflict
  ): todo_app_users

  # update data of the table: "audit.logged_actions"
  update_audit_logged_actions(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: audit_logged_actions_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: audit_logged_actions_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: audit_logged_actions_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: audit_logged_actions_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: audit_logged_actions_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: audit_logged_actions_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: audit_logged_actions_set_input

    # filter the rows which have to be updated
    where: audit_logged_actions_bool_exp!
  ): audit_logged_actions_mutation_response

  # update single row of the table: "audit.logged_actions"
  update_audit_logged_actions_by_pk(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: audit_logged_actions_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: audit_logged_actions_delete_at_path_input

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _delete_elem: audit_logged_actions_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: audit_logged_actions_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: audit_logged_actions_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: audit_logged_actions_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: audit_logged_actions_set_input
    pk_columns: audit_logged_actions_pk_columns_input!
  ): audit_logged_actions

  # update data of the table: "cpf.annotation_categories"
  update_cpf_annotation_categories(
    # sets the columns of the filtered rows to the given values
    _set: cpf_annotation_categories_set_input

    # filter the rows which have to be updated
    where: cpf_annotation_categories_bool_exp!
  ): cpf_annotation_categories_mutation_response

  # update single row of the table: "cpf.annotation_categories"
  update_cpf_annotation_categories_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cpf_annotation_categories_set_input
    pk_columns: cpf_annotation_categories_pk_columns_input!
  ): cpf_annotation_categories

  # update data of the table: "cpf.annotations"
  update_cpf_annotations(
    # sets the columns of the filtered rows to the given values
    _set: cpf_annotations_set_input

    # filter the rows which have to be updated
    where: cpf_annotations_bool_exp!
  ): cpf_annotations_mutation_response

  # update single row of the table: "cpf.annotations"
  update_cpf_annotations_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cpf_annotations_set_input
    pk_columns: cpf_annotations_pk_columns_input!
  ): cpf_annotations

  # update data of the table: "cpf.custom_forms_library"
  update_cpf_custom_forms_library(
    # sets the columns of the filtered rows to the given values
    _set: cpf_custom_forms_library_set_input

    # filter the rows which have to be updated
    where: cpf_custom_forms_library_bool_exp!
  ): cpf_custom_forms_library_mutation_response

  # update single row of the table: "cpf.custom_forms_library"
  update_cpf_custom_forms_library_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cpf_custom_forms_library_set_input
    pk_columns: cpf_custom_forms_library_pk_columns_input!
  ): cpf_custom_forms_library

  # update data of the table: "cpf.custom_forms_library_file_versions"
  update_cpf_custom_forms_library_file_versions(
    # sets the columns of the filtered rows to the given values
    _set: cpf_custom_forms_library_file_versions_set_input

    # filter the rows which have to be updated
    where: cpf_custom_forms_library_file_versions_bool_exp!
  ): cpf_custom_forms_library_file_versions_mutation_response

  # update single row of the table: "cpf.custom_forms_library_file_versions"
  update_cpf_custom_forms_library_file_versions_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cpf_custom_forms_library_file_versions_set_input
    pk_columns: cpf_custom_forms_library_file_versions_pk_columns_input!
  ): cpf_custom_forms_library_file_versions

  # update data of the table: "cpf.custom_forms_library_regions"
  update_cpf_custom_forms_library_regions(
    # sets the columns of the filtered rows to the given values
    _set: cpf_custom_forms_library_regions_set_input

    # filter the rows which have to be updated
    where: cpf_custom_forms_library_regions_bool_exp!
  ): cpf_custom_forms_library_regions_mutation_response

  # update single row of the table: "cpf.custom_forms_library_regions"
  update_cpf_custom_forms_library_regions_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cpf_custom_forms_library_regions_set_input
    pk_columns: cpf_custom_forms_library_regions_pk_columns_input!
  ): cpf_custom_forms_library_regions

  # update data of the table: "cpf.custom_forms_library_tax_types"
  update_cpf_custom_forms_library_tax_types(
    # sets the columns of the filtered rows to the given values
    _set: cpf_custom_forms_library_tax_types_set_input

    # filter the rows which have to be updated
    where: cpf_custom_forms_library_tax_types_bool_exp!
  ): cpf_custom_forms_library_tax_types_mutation_response

  # update single row of the table: "cpf.custom_forms_library_tax_types"
  update_cpf_custom_forms_library_tax_types_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cpf_custom_forms_library_tax_types_set_input
    pk_columns: cpf_custom_forms_library_tax_types_pk_columns_input!
  ): cpf_custom_forms_library_tax_types

  # update data of the table: "cpf.customers"
  update_cpf_customers(
    # increments the integer columns with given value of the filtered values
    _inc: cpf_customers_inc_input

    # sets the columns of the filtered rows to the given values
    _set: cpf_customers_set_input

    # filter the rows which have to be updated
    where: cpf_customers_bool_exp!
  ): cpf_customers_mutation_response

  # update single row of the table: "cpf.customers"
  update_cpf_customers_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: cpf_customers_inc_input

    # sets the columns of the filtered rows to the given values
    _set: cpf_customers_set_input
    pk_columns: cpf_customers_pk_columns_input!
  ): cpf_customers

  # update data of the table: "cpf.customers_users"
  update_cpf_customers_users(
    # sets the columns of the filtered rows to the given values
    _set: cpf_customers_users_set_input

    # filter the rows which have to be updated
    where: cpf_customers_users_bool_exp!
  ): cpf_customers_users_mutation_response

  # update single row of the table: "cpf.customers_users"
  update_cpf_customers_users_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cpf_customers_users_set_input
    pk_columns: cpf_customers_users_pk_columns_input!
  ): cpf_customers_users

  # update data of the table: "cpf.email_queue"
  update_cpf_email_queue(
    # increments the integer columns with given value of the filtered values
    _inc: cpf_email_queue_inc_input

    # sets the columns of the filtered rows to the given values
    _set: cpf_email_queue_set_input

    # filter the rows which have to be updated
    where: cpf_email_queue_bool_exp!
  ): cpf_email_queue_mutation_response

  # update single row of the table: "cpf.email_queue"
  update_cpf_email_queue_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: cpf_email_queue_inc_input

    # sets the columns of the filtered rows to the given values
    _set: cpf_email_queue_set_input
    pk_columns: cpf_email_queue_pk_columns_input!
  ): cpf_email_queue

  # update data of the table: "cpf.email_status"
  update_cpf_email_status(
    # sets the columns of the filtered rows to the given values
    _set: cpf_email_status_set_input

    # filter the rows which have to be updated
    where: cpf_email_status_bool_exp!
  ): cpf_email_status_mutation_response

  # update single row of the table: "cpf.email_status"
  update_cpf_email_status_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cpf_email_status_set_input
    pk_columns: cpf_email_status_pk_columns_input!
  ): cpf_email_status

  # update data of the table: "cpf.email_templates"
  update_cpf_email_templates(
    # sets the columns of the filtered rows to the given values
    _set: cpf_email_templates_set_input

    # filter the rows which have to be updated
    where: cpf_email_templates_bool_exp!
  ): cpf_email_templates_mutation_response

  # update single row of the table: "cpf.email_templates"
  update_cpf_email_templates_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cpf_email_templates_set_input
    pk_columns: cpf_email_templates_pk_columns_input!
  ): cpf_email_templates

  # update data of the table: "cpf.level"
  update_cpf_level(
    # sets the columns of the filtered rows to the given values
    _set: cpf_level_set_input

    # filter the rows which have to be updated
    where: cpf_level_bool_exp!
  ): cpf_level_mutation_response

  # update single row of the table: "cpf.level"
  update_cpf_level_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cpf_level_set_input
    pk_columns: cpf_level_pk_columns_input!
  ): cpf_level

  # update data of the table: "cpf.package_request_status"
  update_cpf_package_request_status(
    # sets the columns of the filtered rows to the given values
    _set: cpf_package_request_status_set_input

    # filter the rows which have to be updated
    where: cpf_package_request_status_bool_exp!
  ): cpf_package_request_status_mutation_response

  # update single row of the table: "cpf.package_request_status"
  update_cpf_package_request_status_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cpf_package_request_status_set_input
    pk_columns: cpf_package_request_status_pk_columns_input!
  ): cpf_package_request_status

  # update data of the table: "cpf.package_requests"
  update_cpf_package_requests(
    # sets the columns of the filtered rows to the given values
    _set: cpf_package_requests_set_input

    # filter the rows which have to be updated
    where: cpf_package_requests_bool_exp!
  ): cpf_package_requests_mutation_response

  # update single row of the table: "cpf.package_requests"
  update_cpf_package_requests_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cpf_package_requests_set_input
    pk_columns: cpf_package_requests_pk_columns_input!
  ): cpf_package_requests

  # update data of the table: "cpf.package_responses"
  update_cpf_package_responses(
    # sets the columns of the filtered rows to the given values
    _set: cpf_package_responses_set_input

    # filter the rows which have to be updated
    where: cpf_package_responses_bool_exp!
  ): cpf_package_responses_mutation_response

  # update single row of the table: "cpf.package_responses"
  update_cpf_package_responses_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cpf_package_responses_set_input
    pk_columns: cpf_package_responses_pk_columns_input!
  ): cpf_package_responses

  # update data of the table: "cpf.packages"
  update_cpf_packages(
    # sets the columns of the filtered rows to the given values
    _set: cpf_packages_set_input

    # filter the rows which have to be updated
    where: cpf_packages_bool_exp!
  ): cpf_packages_mutation_response

  # update single row of the table: "cpf.packages"
  update_cpf_packages_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cpf_packages_set_input
    pk_columns: cpf_packages_pk_columns_input!
  ): cpf_packages

  # update data of the table: "cpf.regions"
  update_cpf_regions(
    # sets the columns of the filtered rows to the given values
    _set: cpf_regions_set_input

    # filter the rows which have to be updated
    where: cpf_regions_bool_exp!
  ): cpf_regions_mutation_response

  # update single row of the table: "cpf.regions"
  update_cpf_regions_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cpf_regions_set_input
    pk_columns: cpf_regions_pk_columns_input!
  ): cpf_regions

  # update data of the table: "cpf.tax_types"
  update_cpf_tax_types(
    # sets the columns of the filtered rows to the given values
    _set: cpf_tax_types_set_input

    # filter the rows which have to be updated
    where: cpf_tax_types_bool_exp!
  ): cpf_tax_types_mutation_response

  # update single row of the table: "cpf.tax_types"
  update_cpf_tax_types_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cpf_tax_types_set_input
    pk_columns: cpf_tax_types_pk_columns_input!
  ): cpf_tax_types

  # update data of the table: "cpf.tenants"
  update_cpf_tenants(
    # sets the columns of the filtered rows to the given values
    _set: cpf_tenants_set_input

    # filter the rows which have to be updated
    where: cpf_tenants_bool_exp!
  ): cpf_tenants_mutation_response

  # update single row of the table: "cpf.tenants"
  update_cpf_tenants_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cpf_tenants_set_input
    pk_columns: cpf_tenants_pk_columns_input!
  ): cpf_tenants

  # update data of the table: "cpf.tenants_users"
  update_cpf_tenants_users(
    # sets the columns of the filtered rows to the given values
    _set: cpf_tenants_users_set_input

    # filter the rows which have to be updated
    where: cpf_tenants_users_bool_exp!
  ): cpf_tenants_users_mutation_response

  # update single row of the table: "cpf.tenants_users"
  update_cpf_tenants_users_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cpf_tenants_users_set_input
    pk_columns: cpf_tenants_users_pk_columns_input!
  ): cpf_tenants_users

  # update data of the table: "cpf.user_roles"
  update_cpf_user_roles(
    # sets the columns of the filtered rows to the given values
    _set: cpf_user_roles_set_input

    # filter the rows which have to be updated
    where: cpf_user_roles_bool_exp!
  ): cpf_user_roles_mutation_response

  # update single row of the table: "cpf.user_roles"
  update_cpf_user_roles_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cpf_user_roles_set_input
    pk_columns: cpf_user_roles_pk_columns_input!
  ): cpf_user_roles

  # update data of the table: "cpf.users"
  update_cpf_users(
    # sets the columns of the filtered rows to the given values
    _set: cpf_users_set_input

    # filter the rows which have to be updated
    where: cpf_users_bool_exp!
  ): cpf_users_mutation_response

  # update single row of the table: "cpf.users"
  update_cpf_users_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cpf_users_set_input
    pk_columns: cpf_users_pk_columns_input!
  ): cpf_users

  # update data of the table: "todo_app.todos"
  update_todo_app_todos(
    # increments the integer columns with given value of the filtered values
    _inc: todo_app_todos_inc_input

    # sets the columns of the filtered rows to the given values
    _set: todo_app_todos_set_input

    # filter the rows which have to be updated
    where: todo_app_todos_bool_exp!
  ): todo_app_todos_mutation_response

  # update single row of the table: "todo_app.todos"
  update_todo_app_todos_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: todo_app_todos_inc_input

    # sets the columns of the filtered rows to the given values
    _set: todo_app_todos_set_input
    pk_columns: todo_app_todos_pk_columns_input!
  ): todo_app_todos

  # update data of the table: "todo_app.users"
  update_todo_app_users(
    # increments the integer columns with given value of the filtered values
    _inc: todo_app_users_inc_input

    # sets the columns of the filtered rows to the given values
    _set: todo_app_users_set_input

    # filter the rows which have to be updated
    where: todo_app_users_bool_exp!
  ): todo_app_users_mutation_response

  # update single row of the table: "todo_app.users"
  update_todo_app_users_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: todo_app_users_inc_input

    # sets the columns of the filtered rows to the given values
    _set: todo_app_users_set_input
    pk_columns: todo_app_users_pk_columns_input!
  ): todo_app_users
}

# An object with globally unique ID
interface Node {
  # A globally unique identifier
  id: ID!
}

scalar oid

# expression to compare columns of type oid. All fields are combined with logical 'AND'.
input oid_comparison_exp {
  _eq: oid
  _gt: oid
  _gte: oid
  _in: [oid!]
  _is_null: Boolean
  _lt: oid
  _lte: oid
  _neq: oid
  _nin: [oid!]
}

# column ordering options
enum order_by {
  # in the ascending order, nulls last
  asc

  # in the ascending order, nulls first
  asc_nulls_first

  # in the ascending order, nulls last
  asc_nulls_last

  # in the descending order, nulls first
  desc

  # in the descending order, nulls first
  desc_nulls_first

  # in the descending order, nulls last
  desc_nulls_last
}

type PageInfo {
  endCursor: String!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
}

# query root
type query_root {
  # fetch data from the table: "audit.logged_actions"
  audit_logged_actions_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [audit_logged_actions_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [audit_logged_actions_order_by!]

    # filter the rows returned
    where: audit_logged_actions_bool_exp
  ): audit_logged_actionsConnection!

  # fetch data from the table: "cpf.annotation_categories"
  cpf_annotation_categories_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_annotation_categories_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotation_categories_order_by!]

    # filter the rows returned
    where: cpf_annotation_categories_bool_exp
  ): cpf_annotation_categoriesConnection!

  # fetch data from the table: "cpf.annotations"
  cpf_annotations_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotationsConnection!

  # fetch data from the table: "cpf.custom_forms_library"
  cpf_custom_forms_library_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_bool_exp
  ): cpf_custom_forms_libraryConnection!

  # fetch data from the table: "cpf.custom_forms_library_file_versions"
  cpf_custom_forms_library_file_versions_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_file_versions_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_file_versions_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_file_versions_bool_exp
  ): cpf_custom_forms_library_file_versionsConnection!

  # fetch data from the table: "cpf.custom_forms_library_regions"
  cpf_custom_forms_library_regions_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_regions_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_regions_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_regions_bool_exp
  ): cpf_custom_forms_library_regionsConnection!

  # fetch data from the table: "cpf.custom_forms_library_tax_types"
  cpf_custom_forms_library_tax_types_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_tax_types_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_tax_types_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_tax_types_bool_exp
  ): cpf_custom_forms_library_tax_typesConnection!

  # fetch data from the table: "cpf.customers"
  cpf_customers_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_customers_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_customers_order_by!]

    # filter the rows returned
    where: cpf_customers_bool_exp
  ): cpf_customersConnection!

  # fetch data from the table: "cpf.customers_users"
  cpf_customers_users_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_customers_users_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_customers_users_order_by!]

    # filter the rows returned
    where: cpf_customers_users_bool_exp
  ): cpf_customers_usersConnection!

  # fetch data from the table: "cpf.email_queue"
  cpf_email_queue_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_email_queue_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_email_queue_order_by!]

    # filter the rows returned
    where: cpf_email_queue_bool_exp
  ): cpf_email_queueConnection!

  # fetch data from the table: "cpf.email_status"
  cpf_email_status_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_email_status_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_email_status_order_by!]

    # filter the rows returned
    where: cpf_email_status_bool_exp
  ): cpf_email_statusConnection!

  # fetch data from the table: "cpf.email_templates"
  cpf_email_templates_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_email_templates_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_email_templates_order_by!]

    # filter the rows returned
    where: cpf_email_templates_bool_exp
  ): cpf_email_templatesConnection!

  # fetch data from the table: "cpf.level"
  cpf_level_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_level_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_level_order_by!]

    # filter the rows returned
    where: cpf_level_bool_exp
  ): cpf_levelConnection!

  # fetch data from the table: "cpf.package_request_status"
  cpf_package_request_status_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_package_request_status_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_package_request_status_order_by!]

    # filter the rows returned
    where: cpf_package_request_status_bool_exp
  ): cpf_package_request_statusConnection!

  # fetch data from the table: "cpf.package_requests"
  cpf_package_requests_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_package_requests_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_package_requests_order_by!]

    # filter the rows returned
    where: cpf_package_requests_bool_exp
  ): cpf_package_requestsConnection!

  # fetch data from the table: "cpf.package_responses"
  cpf_package_responses_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_package_responses_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_package_responses_order_by!]

    # filter the rows returned
    where: cpf_package_responses_bool_exp
  ): cpf_package_responsesConnection!

  # fetch data from the table: "cpf.packages"
  cpf_packages_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_packages_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_packages_order_by!]

    # filter the rows returned
    where: cpf_packages_bool_exp
  ): cpf_packagesConnection!

  # fetch data from the table: "cpf.regions"
  cpf_regions_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_regions_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_regions_order_by!]

    # filter the rows returned
    where: cpf_regions_bool_exp
  ): cpf_regionsConnection!

  # fetch data from the table: "cpf.tax_types"
  cpf_tax_types_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_tax_types_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_tax_types_order_by!]

    # filter the rows returned
    where: cpf_tax_types_bool_exp
  ): cpf_tax_typesConnection!

  # fetch data from the table: "cpf.tenants"
  cpf_tenants_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_tenants_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_tenants_order_by!]

    # filter the rows returned
    where: cpf_tenants_bool_exp
  ): cpf_tenantsConnection!

  # fetch data from the table: "cpf.tenants_users"
  cpf_tenants_users_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_tenants_users_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_tenants_users_order_by!]

    # filter the rows returned
    where: cpf_tenants_users_bool_exp
  ): cpf_tenants_usersConnection!

  # fetch data from the table: "cpf.user_roles"
  cpf_user_roles_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_user_roles_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_user_roles_order_by!]

    # filter the rows returned
    where: cpf_user_roles_bool_exp
  ): cpf_user_rolesConnection!

  # fetch data from the table: "cpf.users"
  cpf_users_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_users_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_users_order_by!]

    # filter the rows returned
    where: cpf_users_bool_exp
  ): cpf_usersConnection!
  node(
    # A globally unique id
    id: ID!
  ): Node

  # fetch data from the table: "todo_app.todos"
  todo_app_todos_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [todo_app_todos_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [todo_app_todos_order_by!]

    # filter the rows returned
    where: todo_app_todos_bool_exp
  ): todo_app_todosConnection!

  # fetch data from the table: "todo_app.users"
  todo_app_users_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [todo_app_users_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [todo_app_users_order_by!]

    # filter the rows returned
    where: todo_app_users_bool_exp
  ): todo_app_usersConnection!
}

# expression to compare columns of type String. All fields are combined with logical 'AND'.
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

# subscription root
type subscription_root {
  # fetch data from the table: "audit.logged_actions"
  audit_logged_actions_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [audit_logged_actions_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [audit_logged_actions_order_by!]

    # filter the rows returned
    where: audit_logged_actions_bool_exp
  ): audit_logged_actionsConnection!

  # fetch data from the table: "cpf.annotation_categories"
  cpf_annotation_categories_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_annotation_categories_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotation_categories_order_by!]

    # filter the rows returned
    where: cpf_annotation_categories_bool_exp
  ): cpf_annotation_categoriesConnection!

  # fetch data from the table: "cpf.annotations"
  cpf_annotations_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_annotations_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_annotations_order_by!]

    # filter the rows returned
    where: cpf_annotations_bool_exp
  ): cpf_annotationsConnection!

  # fetch data from the table: "cpf.custom_forms_library"
  cpf_custom_forms_library_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_bool_exp
  ): cpf_custom_forms_libraryConnection!

  # fetch data from the table: "cpf.custom_forms_library_file_versions"
  cpf_custom_forms_library_file_versions_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_file_versions_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_file_versions_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_file_versions_bool_exp
  ): cpf_custom_forms_library_file_versionsConnection!

  # fetch data from the table: "cpf.custom_forms_library_regions"
  cpf_custom_forms_library_regions_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_regions_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_regions_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_regions_bool_exp
  ): cpf_custom_forms_library_regionsConnection!

  # fetch data from the table: "cpf.custom_forms_library_tax_types"
  cpf_custom_forms_library_tax_types_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_custom_forms_library_tax_types_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_custom_forms_library_tax_types_order_by!]

    # filter the rows returned
    where: cpf_custom_forms_library_tax_types_bool_exp
  ): cpf_custom_forms_library_tax_typesConnection!

  # fetch data from the table: "cpf.customers"
  cpf_customers_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_customers_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_customers_order_by!]

    # filter the rows returned
    where: cpf_customers_bool_exp
  ): cpf_customersConnection!

  # fetch data from the table: "cpf.customers_users"
  cpf_customers_users_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_customers_users_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_customers_users_order_by!]

    # filter the rows returned
    where: cpf_customers_users_bool_exp
  ): cpf_customers_usersConnection!

  # fetch data from the table: "cpf.email_queue"
  cpf_email_queue_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_email_queue_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_email_queue_order_by!]

    # filter the rows returned
    where: cpf_email_queue_bool_exp
  ): cpf_email_queueConnection!

  # fetch data from the table: "cpf.email_status"
  cpf_email_status_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_email_status_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_email_status_order_by!]

    # filter the rows returned
    where: cpf_email_status_bool_exp
  ): cpf_email_statusConnection!

  # fetch data from the table: "cpf.email_templates"
  cpf_email_templates_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_email_templates_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_email_templates_order_by!]

    # filter the rows returned
    where: cpf_email_templates_bool_exp
  ): cpf_email_templatesConnection!

  # fetch data from the table: "cpf.level"
  cpf_level_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_level_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_level_order_by!]

    # filter the rows returned
    where: cpf_level_bool_exp
  ): cpf_levelConnection!

  # fetch data from the table: "cpf.package_request_status"
  cpf_package_request_status_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_package_request_status_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_package_request_status_order_by!]

    # filter the rows returned
    where: cpf_package_request_status_bool_exp
  ): cpf_package_request_statusConnection!

  # fetch data from the table: "cpf.package_requests"
  cpf_package_requests_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_package_requests_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_package_requests_order_by!]

    # filter the rows returned
    where: cpf_package_requests_bool_exp
  ): cpf_package_requestsConnection!

  # fetch data from the table: "cpf.package_responses"
  cpf_package_responses_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_package_responses_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_package_responses_order_by!]

    # filter the rows returned
    where: cpf_package_responses_bool_exp
  ): cpf_package_responsesConnection!

  # fetch data from the table: "cpf.packages"
  cpf_packages_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_packages_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_packages_order_by!]

    # filter the rows returned
    where: cpf_packages_bool_exp
  ): cpf_packagesConnection!

  # fetch data from the table: "cpf.regions"
  cpf_regions_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_regions_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_regions_order_by!]

    # filter the rows returned
    where: cpf_regions_bool_exp
  ): cpf_regionsConnection!

  # fetch data from the table: "cpf.tax_types"
  cpf_tax_types_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_tax_types_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_tax_types_order_by!]

    # filter the rows returned
    where: cpf_tax_types_bool_exp
  ): cpf_tax_typesConnection!

  # fetch data from the table: "cpf.tenants"
  cpf_tenants_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_tenants_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_tenants_order_by!]

    # filter the rows returned
    where: cpf_tenants_bool_exp
  ): cpf_tenantsConnection!

  # fetch data from the table: "cpf.tenants_users"
  cpf_tenants_users_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_tenants_users_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_tenants_users_order_by!]

    # filter the rows returned
    where: cpf_tenants_users_bool_exp
  ): cpf_tenants_usersConnection!

  # fetch data from the table: "cpf.user_roles"
  cpf_user_roles_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_user_roles_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_user_roles_order_by!]

    # filter the rows returned
    where: cpf_user_roles_bool_exp
  ): cpf_user_rolesConnection!

  # fetch data from the table: "cpf.users"
  cpf_users_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [cpf_users_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [cpf_users_order_by!]

    # filter the rows returned
    where: cpf_users_bool_exp
  ): cpf_usersConnection!
  node(
    # A globally unique id
    id: ID!
  ): Node

  # fetch data from the table: "todo_app.todos"
  todo_app_todos_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [todo_app_todos_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [todo_app_todos_order_by!]

    # filter the rows returned
    where: todo_app_todos_bool_exp
  ): todo_app_todosConnection!

  # fetch data from the table: "todo_app.users"
  todo_app_users_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [todo_app_users_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [todo_app_users_order_by!]

    # filter the rows returned
    where: todo_app_users_bool_exp
  ): todo_app_usersConnection!
}

scalar timestamptz

# expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

# columns and relationships of "todo_app.todos"
type todo_app_todos implements Node {
  complete: Boolean!
  id: ID!
  text: String!
  todo_id: uuid!

  # An object relationship
  user: todo_app_users!
  user_id: Int!
}

# aggregated selection of "todo_app.todos"
type todo_app_todos_aggregate {
  aggregate: todo_app_todos_aggregate_fields
  nodes: [todo_app_todos!]!
}

# aggregate fields of "todo_app.todos"
type todo_app_todos_aggregate_fields {
  avg: todo_app_todos_avg_fields
  count(columns: [todo_app_todos_select_column!], distinct: Boolean): Int
  max: todo_app_todos_max_fields
  min: todo_app_todos_min_fields
  stddev: todo_app_todos_stddev_fields
  stddev_pop: todo_app_todos_stddev_pop_fields
  stddev_samp: todo_app_todos_stddev_samp_fields
  sum: todo_app_todos_sum_fields
  var_pop: todo_app_todos_var_pop_fields
  var_samp: todo_app_todos_var_samp_fields
  variance: todo_app_todos_variance_fields
}

# order by aggregate values of table "todo_app.todos"
input todo_app_todos_aggregate_order_by {
  avg: todo_app_todos_avg_order_by
  count: order_by
  max: todo_app_todos_max_order_by
  min: todo_app_todos_min_order_by
  stddev: todo_app_todos_stddev_order_by
  stddev_pop: todo_app_todos_stddev_pop_order_by
  stddev_samp: todo_app_todos_stddev_samp_order_by
  sum: todo_app_todos_sum_order_by
  var_pop: todo_app_todos_var_pop_order_by
  var_samp: todo_app_todos_var_samp_order_by
  variance: todo_app_todos_variance_order_by
}

# input type for inserting array relation for remote table "todo_app.todos"
input todo_app_todos_arr_rel_insert_input {
  data: [todo_app_todos_insert_input!]!
  on_conflict: todo_app_todos_on_conflict
}

# aggregate avg on columns
type todo_app_todos_avg_fields {
  user_id: Float
}

# order by avg() on columns of table "todo_app.todos"
input todo_app_todos_avg_order_by {
  user_id: order_by
}

# Boolean expression to filter rows from the table "todo_app.todos". All fields are combined with a logical 'AND'.
input todo_app_todos_bool_exp {
  _and: [todo_app_todos_bool_exp]
  _not: todo_app_todos_bool_exp
  _or: [todo_app_todos_bool_exp]
  complete: Boolean_comparison_exp
  text: String_comparison_exp
  todo_id: uuid_comparison_exp
  user: todo_app_users_bool_exp
  user_id: Int_comparison_exp
}

# unique or primary key constraints on table "todo_app.todos"
enum todo_app_todos_constraint {
  # unique or primary key constraint
  todos_pkey
}

# input type for incrementing integer column in table "todo_app.todos"
input todo_app_todos_inc_input {
  user_id: Int
}

# input type for inserting data into table "todo_app.todos"
input todo_app_todos_insert_input {
  complete: Boolean
  text: String
  todo_id: uuid
  user: todo_app_users_obj_rel_insert_input
  user_id: Int
}

# aggregate max on columns
type todo_app_todos_max_fields {
  text: String
  todo_id: uuid
  user_id: Int
}

# order by max() on columns of table "todo_app.todos"
input todo_app_todos_max_order_by {
  text: order_by
  todo_id: order_by
  user_id: order_by
}

# aggregate min on columns
type todo_app_todos_min_fields {
  text: String
  todo_id: uuid
  user_id: Int
}

# order by min() on columns of table "todo_app.todos"
input todo_app_todos_min_order_by {
  text: order_by
  todo_id: order_by
  user_id: order_by
}

# response of any mutation on the table "todo_app.todos"
type todo_app_todos_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [todo_app_todos!]!
}

# input type for inserting object relation for remote table "todo_app.todos"
input todo_app_todos_obj_rel_insert_input {
  data: todo_app_todos_insert_input!
  on_conflict: todo_app_todos_on_conflict
}

# on conflict condition type for table "todo_app.todos"
input todo_app_todos_on_conflict {
  constraint: todo_app_todos_constraint!
  update_columns: [todo_app_todos_update_column!]!
  where: todo_app_todos_bool_exp
}

# ordering options when selecting data from "todo_app.todos"
input todo_app_todos_order_by {
  complete: order_by
  text: order_by
  todo_id: order_by
  user: todo_app_users_order_by
  user_id: order_by
}

# primary key columns input for table: "todo_app.todos"
input todo_app_todos_pk_columns_input {
  todo_id: uuid!
}

# select columns of table "todo_app.todos"
enum todo_app_todos_select_column {
  # column name
  complete

  # column name
  text

  # column name
  todo_id

  # column name
  user_id
}

# input type for updating data in table "todo_app.todos"
input todo_app_todos_set_input {
  complete: Boolean
  text: String
  todo_id: uuid
  user_id: Int
}

# aggregate stddev on columns
type todo_app_todos_stddev_fields {
  user_id: Float
}

# order by stddev() on columns of table "todo_app.todos"
input todo_app_todos_stddev_order_by {
  user_id: order_by
}

# aggregate stddev_pop on columns
type todo_app_todos_stddev_pop_fields {
  user_id: Float
}

# order by stddev_pop() on columns of table "todo_app.todos"
input todo_app_todos_stddev_pop_order_by {
  user_id: order_by
}

# aggregate stddev_samp on columns
type todo_app_todos_stddev_samp_fields {
  user_id: Float
}

# order by stddev_samp() on columns of table "todo_app.todos"
input todo_app_todos_stddev_samp_order_by {
  user_id: order_by
}

# aggregate sum on columns
type todo_app_todos_sum_fields {
  user_id: Int
}

# order by sum() on columns of table "todo_app.todos"
input todo_app_todos_sum_order_by {
  user_id: order_by
}

# update columns of table "todo_app.todos"
enum todo_app_todos_update_column {
  # column name
  complete

  # column name
  text

  # column name
  todo_id

  # column name
  user_id
}

# aggregate var_pop on columns
type todo_app_todos_var_pop_fields {
  user_id: Float
}

# order by var_pop() on columns of table "todo_app.todos"
input todo_app_todos_var_pop_order_by {
  user_id: order_by
}

# aggregate var_samp on columns
type todo_app_todos_var_samp_fields {
  user_id: Float
}

# order by var_samp() on columns of table "todo_app.todos"
input todo_app_todos_var_samp_order_by {
  user_id: order_by
}

# aggregate variance on columns
type todo_app_todos_variance_fields {
  user_id: Float
}

# order by variance() on columns of table "todo_app.todos"
input todo_app_todos_variance_order_by {
  user_id: order_by
}

# A Relay Connection object on "todo_app.todos"
type todo_app_todosConnection {
  edges: [todo_app_todosEdge!]!
  pageInfo: PageInfo!
}

type todo_app_todosEdge {
  cursor: String!
  node: todo_app_todos!
}

# columns and relationships of "todo_app.users"
type todo_app_users implements Node {
  id: ID!
  name: String!

  # An array relationship
  todos(
    # distinct select on columns
    distinct_on: [todo_app_todos_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [todo_app_todos_order_by!]

    # filter the rows returned
    where: todo_app_todos_bool_exp
  ): [todo_app_todos!]!

  # An aggregated array relationship
  todos_aggregate(
    # distinct select on columns
    distinct_on: [todo_app_todos_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [todo_app_todos_order_by!]

    # filter the rows returned
    where: todo_app_todos_bool_exp
  ): todo_app_todos_aggregate!

  # An array relationship connection
  todos_connection(
    after: String
    before: String

    # distinct select on columns
    distinct_on: [todo_app_todos_select_column!]
    first: Int
    last: Int

    # sort the rows by one or more columns
    order_by: [todo_app_todos_order_by!]

    # filter the rows returned
    where: todo_app_todos_bool_exp
  ): todo_app_todosConnection!
}

# aggregated selection of "todo_app.users"
type todo_app_users_aggregate {
  aggregate: todo_app_users_aggregate_fields
  nodes: [todo_app_users!]!
}

# aggregate fields of "todo_app.users"
type todo_app_users_aggregate_fields {
  avg: todo_app_users_avg_fields
  count(columns: [todo_app_users_select_column!], distinct: Boolean): Int
  max: todo_app_users_max_fields
  min: todo_app_users_min_fields
  stddev: todo_app_users_stddev_fields
  stddev_pop: todo_app_users_stddev_pop_fields
  stddev_samp: todo_app_users_stddev_samp_fields
  sum: todo_app_users_sum_fields
  var_pop: todo_app_users_var_pop_fields
  var_samp: todo_app_users_var_samp_fields
  variance: todo_app_users_variance_fields
}

# order by aggregate values of table "todo_app.users"
input todo_app_users_aggregate_order_by {
  avg: todo_app_users_avg_order_by
  count: order_by
  max: todo_app_users_max_order_by
  min: todo_app_users_min_order_by
  stddev: todo_app_users_stddev_order_by
  stddev_pop: todo_app_users_stddev_pop_order_by
  stddev_samp: todo_app_users_stddev_samp_order_by
  sum: todo_app_users_sum_order_by
  var_pop: todo_app_users_var_pop_order_by
  var_samp: todo_app_users_var_samp_order_by
  variance: todo_app_users_variance_order_by
}

# input type for inserting array relation for remote table "todo_app.users"
input todo_app_users_arr_rel_insert_input {
  data: [todo_app_users_insert_input!]!
  on_conflict: todo_app_users_on_conflict
}

# aggregate avg on columns
type todo_app_users_avg_fields {
  id: Float
}

# order by avg() on columns of table "todo_app.users"
input todo_app_users_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "todo_app.users". All fields are combined with a logical 'AND'.
input todo_app_users_bool_exp {
  _and: [todo_app_users_bool_exp]
  _not: todo_app_users_bool_exp
  _or: [todo_app_users_bool_exp]
  id: Int_comparison_exp
  name: String_comparison_exp
  todos: todo_app_todos_bool_exp
}

# unique or primary key constraints on table "todo_app.users"
enum todo_app_users_constraint {
  # unique or primary key constraint
  users_pkey
}

# input type for incrementing integer column in table "todo_app.users"
input todo_app_users_inc_input {
  id: Int
}

# input type for inserting data into table "todo_app.users"
input todo_app_users_insert_input {
  id: Int
  name: String
  todos: todo_app_todos_arr_rel_insert_input
}

# aggregate max on columns
type todo_app_users_max_fields {
  id: Int
  name: String
}

# order by max() on columns of table "todo_app.users"
input todo_app_users_max_order_by {
  id: order_by
  name: order_by
}

# aggregate min on columns
type todo_app_users_min_fields {
  id: Int
  name: String
}

# order by min() on columns of table "todo_app.users"
input todo_app_users_min_order_by {
  id: order_by
  name: order_by
}

# response of any mutation on the table "todo_app.users"
type todo_app_users_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [todo_app_users!]!
}

# input type for inserting object relation for remote table "todo_app.users"
input todo_app_users_obj_rel_insert_input {
  data: todo_app_users_insert_input!
  on_conflict: todo_app_users_on_conflict
}

# on conflict condition type for table "todo_app.users"
input todo_app_users_on_conflict {
  constraint: todo_app_users_constraint!
  update_columns: [todo_app_users_update_column!]!
  where: todo_app_users_bool_exp
}

# ordering options when selecting data from "todo_app.users"
input todo_app_users_order_by {
  id: order_by
  name: order_by
  todos_aggregate: todo_app_todos_aggregate_order_by
}

# primary key columns input for table: "todo_app.users"
input todo_app_users_pk_columns_input {
  id: Int!
}

# select columns of table "todo_app.users"
enum todo_app_users_select_column {
  # column name
  id

  # column name
  name
}

# input type for updating data in table "todo_app.users"
input todo_app_users_set_input {
  id: Int
  name: String
}

# aggregate stddev on columns
type todo_app_users_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "todo_app.users"
input todo_app_users_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type todo_app_users_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "todo_app.users"
input todo_app_users_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type todo_app_users_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "todo_app.users"
input todo_app_users_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type todo_app_users_sum_fields {
  id: Int
}

# order by sum() on columns of table "todo_app.users"
input todo_app_users_sum_order_by {
  id: order_by
}

# update columns of table "todo_app.users"
enum todo_app_users_update_column {
  # column name
  id

  # column name
  name
}

# aggregate var_pop on columns
type todo_app_users_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "todo_app.users"
input todo_app_users_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type todo_app_users_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "todo_app.users"
input todo_app_users_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type todo_app_users_variance_fields {
  id: Float
}

# order by variance() on columns of table "todo_app.users"
input todo_app_users_variance_order_by {
  id: order_by
}

# A Relay Connection object on "todo_app.users"
type todo_app_usersConnection {
  edges: [todo_app_usersEdge!]!
  pageInfo: PageInfo!
}

type todo_app_usersEdge {
  cursor: String!
  node: todo_app_users!
}

scalar uuid

# expression to compare columns of type uuid. All fields are combined with logical 'AND'.
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

